{"./":{"url":"./","title":"About","keywords":"","body":"Ai-Thinker GPRS C SDK Documentation Ai-Thinker GPRS C SDK documentation Code of CSDK: GPRS_C_SDK Source code of documention: GPRS_C_SDK_DOC Click Me To Read Online ( 中文 ) About Module Ai-Thinker GPRS module models are mainly A9, A9G. A9 mainly has GSM/GPRS (2G) related functions; A9G also integrates a GPS chip to facilitate the positioning related applications. For more functions, refer to hardware introduction section. Module can be bought at taobao or other ways : taobao link Development The development of modules mainly provides two kinds of interfaces: （A） AT Command: a module connect with MCU with UART It's a easy way to operate GSM/GPRS module, and requires MCU to send command to the module through a serial port(UART), and you just need to find the command you need in AT Command Documentation AT firmware is the default firmware， you can set up immediately, more refer to Ai-Thinker Wiki This document does not contains any infomation of AT Command （B）SDK On Chip Development，No external MCU is needed, burn the firmware directly to GPRS module The advantage of this method is that it doesn't need extra MCU, programming directly on modules, saving hardware resources, and save mony for projects This documentation introduces in detail how to use SDK to develop and provide related API docs. The AT application source code is not included in this SDK "},"hardware/a9.html":{"url":"hardware/a9.html","title":"A9","keywords":"","body":"A9 Features RDA 32 bit RISC core, frequency up to 312MHz, with 4k instruction cache, 4k data cache Up to 29 GPIOs (with two download pins) Calendar (Real Time Clock) with alarm 1 USB1.1 device interface 2 UART interface with flow control (+1 download/debug serial port) 2 SPI interface 3 I 2 C interface 1 SDMMC controller (interface) 2 ADC interface, 10 bits 32Mb (4MB) SPI NOR Flash 32Mb (4MB) DDR PSRAM 8kHz, 13Bits/sample ADC mic 48kHz, 16bits/sample DAC Audio Power Management Unit: Lithium battery charge management, integrated DC-DC and LDOs, variable IO voltage 18.8 x 19.2 mm SMD package Quad-band GSM/GPRS (800/900/1800 / 1900MHz) calls SMS service Hardware Product specification: A9 Product specification doc User manual: user manual(Chinese) Hardware files:A9/A9G hardware files Module pin map(A9 and A9G are compatible with each other) "},"hardware/a9g.html":{"url":"hardware/a9g.html","title":"A9G","keywords":"","body":"A9G Features All features of A9 GPS integrated(GK9501),connected with GPRS chip internal through the serial port(UART2) Hardware GSM/GPRS cpu:RDA8955 Product specification: A9G Product specification doc User manual: user manual(Chinese) Hardware files:A9/A9G hardware files Module pin map(A9 and A9G are compatible with each other) GNSS(GPS) GK9501 Document and tools of GK9501: download: baidu cloud,mega cloud "},"hardware/pudding-dev-board.html":{"url":"hardware/pudding-dev-board.html","title":"pudding dev board","keywords":"","body":"A9/A9G development board:pudding Features 1 A9G module (the board be the same that with A9 and A9G, for the A9 and A9G in the same package, the same pin ) 29 GPIOs with 2.45mm spacing (with 2 download debug pins (HST_TX,HST_RX) One SIM card slot (Nano Card 1 TF card slot 1 GPRS interface with IPEX 1 generation package 1 GPS interface with IPEX 1 generation package 1 micro USB interface 5v-4.2V DC-DC, it can be 5v power supply or 3.8 ~ 4.2V power supply 1 accelerometer chip(LIS3DHx) 1 power key, and a reset button 2 LED 1 microphone Pin Map Schematic A9 schematic: http://wiki.ai-thinker.com/_media/gprs/a9/a9-dev_v1.2.pdf A9G schematic: http://wiki.ai-thinker.com/_media/gprs/a9g/a9g-dev_v1.2.pdf A9 schematic lib: http://wiki.ai-thinker.com/_media/gprs/a9g/a9g-dev_v1.2.zip A9G schematic lib: http://wiki.ai-thinker.com/_media/gprs/a9/a9-dev_v1.2.zip "},"hardware/usb-uart-module.html":{"url":"hardware/usb-uart-module.html","title":"USB-UART module","keywords":"","body":"USB serial port module Burn(Download) program to the development board through the serial port. It needs a USB serial port chip, which can be bought in Taobao or other Electronic shopping mall. Do not recommend the use of PL2303 or CH34 chip USB to the serial port module, may appear driving problems or lack of current, CP2102 is a better choice, buy links: Ai-Thinker USB Serial "},"hardware/sim-card.html":{"url":"hardware/sim-card.html","title":"SIM Card","keywords":"","body":"SIM Card In order to ensure the uniqueness of each device's identity in GSM/GPRS network, a SIM card is needed. Now normal SIM card and eSIM are supported, the former is a card with a chip and contacts, with different sizes: Standard SIM, Micro SIM, Nano SIM; the latter is just a chip, have small size can be directly installed inside the device. "},"basic-knowledge/gsmgprs.html":{"url":"basic-knowledge/gsmgprs.html","title":"GSM/GPRS","keywords":"","body":"Basic knowledgement: GSM/GPRS GSM Global System for Mobile Communications GPRS General Packet Radio Service GPRS is a packet data carrying and transmission service developed on the basis of the GSM system. GSM is a circuit switching system, and GPRS is a packet switching (packet switching) system. About GPRS, here is a brief introduction to some of its simple and important knowledge. More details, please find information to study （1）GPRS classify of service There's three typs:Class A/B/C， Class A: it can support both circuit switching and packet switching, that is, simultaneous telephone and Internet access. Class B: support for circuit switching and packet switching, but only one at the same time. Class C: only support packet switching （2）GPRS Transmission Classify The GPRS network assigns a maximum of 8 timeslots to each user to transmit data, which is composed of up to 8 timeslots and consists of uplink and downlink. Class 2: downlink 2, uplink 1 (2+1) Class 4: downlink 3, uplink 1 (3+1) Class 8: lower 4, uplink 1 (4+1) Class 10: downlink 4, uplink 2 (4+2) Class 12: downlink 4, uplink 4 (4+4) It is important to note that Class 8/10/12 does not mean that there are 8/10/12 channels that can be used, and that there are only 5 total channels, and the classification here illustrates the maximum number of upstream and downlink channels that can be used. GPRS transmission speed: In theory, the greater the class value is, the faster the speed is, but the speed is limited by the minimum speed limit for both the base station and the GPRS device (GPRS module, cell phone). For example, the GPRS device supports Class 12, but the base station only supports Class 10, which will receive the Class 10 limit, and it is also related to the encoding methods, signals, interference and other factors. （3）GPRS Encoding method GPRS defines four channel coding methods, CS-1 to CS-4, with different coding rates and different error correcting abilities. The lower the encoding, the stronger the ability to correct errors, but the lower the speed. so the higher the encoding is, the better the signal is. （4）GPRS How to set up a data communication Register:The GPRS device connects to the base station and registers to the network, and ensure that there is enough strong signal. At that time, GSM service can be used, e.g.:call and SMS. GPRS attachment: Establishing a communication channel from GPRS device to GPRS network, actually attached to SGSN (serving GPRS support node). GPRS PDP Context (packet Data protocol context) activation: Get IP from the GPRS gateway. After activation, the device can communication with publick network(Internet). GGSN (gateway GPRS Support Node) is the key part of the GPRS network, the interaction between the GPRS network and the external packet switching network. From the external network, GGSN is a subnet router, which is responsible for exchanging the information between the SGSN and the external network, and is responsible for the functions of authentication, flow rate and so on. to connect with public network devices: Because the device has been built up to the public network connection, only need to connect directly through a certain protocol, such as the establishment of TCP connection, UDP connection, etc. "},"basic-knowledge/gps.html":{"url":"basic-knowledge/gps.html","title":"GNSS(GPS)","keywords":"","body":"Basic knowledgement: GPS GNSS Global Navigation Satellite System, is the general name of the global satellite navigation system. The GPS, as widely said, is just one of the positioning systems. As follows: GPS:Global Positioning System,sets up by the United States, the global coverage rate is as high as 98%, with a total of 24 satellites. The earliest developed and used positioning system in the world BDS: Chinese BeiDou Navigation Satellite System GLONASS: Build from Russian Galileo: The European Galileo system satellite navigation system QZSS: Japan made it. SBAS: In addition to the satellite positioning system, there are SBAS (Satellite-Based Augmentation System), star based enhancement system, and satellite navigation enhancement signal transponder through the geostationary orbit (GEO) satellite, which can broadcast ephemeris error, satellite clock error, ionospheric delay and so on. The improvement of positioning accuracy of satellite navigation system has become a means of competing development for all space powers. Currently, many SBAS systems have been established in the world, such as the WAAS of the United States (Wide Area Augmentation System), the SDCM of Russia (System for Differential Corrections and), the European Union, and Japan. Mentation System) and GAGAN in India (GPS Aided Geo Augmented Navigation). WGS84,CGCS2000 standard(coordinate system) The position must not be separated from the coordinate system. The coordinate system used by GPS is WGS84 (World Geodetic System 1984) coordinate system. Besides WGS84, China also has CGCS2000 (national geodetic coordinate system). Coordinate deviation standard GCJ-02 BD-09 In addition to multiple coordinates, there is a coordinate deviation standard. The coordinates on the map used by the public are not native WGS84 or CGCS2000 coordinates, all of which are the coordinates after adding random migration to the original coordinates and then encrypt. The migration standards are mainly GCJ-02 (National Bureau of Surveying and mapping No. 02) (Mars coordinates), and BD09 (Baidu coordinates). So in view of the multiple coordinate system and the coordinate deviation standard, it is necessary to pay much attention to the use of location information, what coordinates are obtained and converted in accordance with your own needs. For example, the A9G module output coordinates are WGS84 coordinates, after getting the coordinates to display the Baidu map, the WGS84 coordinates need to be converted to BD09 coordinates, if the map is google map, Martian coordinate should be used, otherwise the location on the map may have a very large deviation!!!! "},"c-sdk/installation.html":{"url":"c-sdk/installation.html","title":"Installation Windows","keywords":"","body":"GPRS C SDK Build environment installation Pay Attention important, please read first SDK does not have a specific IDE, and the user chooses the code editor to edit the code. When modifying the code, you must not use the notepad and writing board that windows brings. Please use a more professional editor (recommended as vscode, sublime, atom, eclipse, source insight, or other editors you are familiar with. ) Please modify the editor settings. The end of the file symbol is set to UNIX style ( (\\n) end), and file encoding is UTF-8 if you are cloned using git, set the git at pull not to convert to , set the method reference here Download tool chain, debug tool and SDK Download CSDTK4.2: baidu cloud,MEGA cloud，direct link Get SDK download SDK or clone by git:git clone https://github.com/Ai-Thinker-Open/GPRS_C_SDK.git --recursive (pay attention --recursive is needed, or compile will fail for lake of files) Check C_SDK platform/csdk folder, there should be some folders and file, if not, you may get source code with wrong way, check and download again installation Decompression to a folder, such as C:\\CSDTK, path please DO NOT bring Chinese! Run config_env_admin.bat file in CSDTK to set environment value What the script does is to create an environment variable named GPRS_CSDTK42_PATH, which has a variable directory value of CSDTK. If the script fails, you can build it by yourself Compile Decompress the CSDK downloaded to GPRS_C_SDK folder into a directory, such as C:\\GPRS_C_SDK, use the underscore(_) instead of minus(-). Step into CSDK folder(C:\\GPRS_C_SDK），right click mouse in th blank space in the folder with shift key pressed, then open with powersheel of cmd. Type ./build.bat app or build.bat app to build app project, ensure our environment is ok. If comes with NO CSDTK error, you may need to restart you system(mostly appears on Win7). Then you can use ./build.bat script to build project: ./build.bat $PROJ:compile app module，e.g.:./build.batsh app to compile the source code of app folder ./build.bat demo $PROJ:compile demo project, e.g.:./build.bat demo gpio to compile gpio demo ./build.bat clean $PROJ:clear the build files of $PROJ ./build.bat clean all:clear all the build files ./build.bat demo $PROJ release:build a release version, e.g.:./build.bat demo gpio release，if the last parameter is not release, it will be default to debug version. The GDB can be used to debug errors after system crashed in debug version, but release version can not, watch dog activate in release version,it will auto restart system when system crashed! e.g.: ./build.sh demo gpio A build folder will be generated after compile, there's two *.lod files in th hex folder, it's the target file that burn(download) to dev board about target hex file(*.lod) There's two hex file,(*_B*.lod and *_flash.lod), you must burn the bigger one to dev board at the first time, then you can just burn the little one to reduce the doanload time. And you must download the bigger if you update the SDK version Other Problems If error occured, please compare the documents carefully to see if the operation is wrong，and find in issue Way A: github add issue Way B: Ai-Thinker forum "},"c-sdk/installation_linux.html":{"url":"c-sdk/installation_linux.html","title":"Installation Linux","keywords":"","body":"GPRS C SDK Build environment installation on Linux Pay Attention important, please read first SDK does not have a specific IDE, and the user chooses the code editor to edit the code.(Like vscode, sublime, atom, eclipse, source insight, or other editors you are familiar with. ) Please modify the editor settings. The end of the file symbol is set to UNIX style ( (\\n) end), and file encoding is UTF-8 if you are cloned using git, set the git at pull not to convert to , set the method reference here Download tool chain, debug tool and SDK Download CSDTK4.2 Linux version: baidu cloud MEGA cloud direct link Get SDK download SDK or clone by git:git clone https://github.com/Ai-Thinker-Open/GPRS_C_SDK.git --recursive (pay attention --recursive is needed, or compile will fail for lake of files) Check C_SDK platform/csdk folder, there should be some folders and file, if not, you may get source code with wrong way, check and download again Installation Install dependences for compile tool sudo apt install build-essential gcc-multilib g++-multilib libzip-dev zlib1g lib32z1 Install dependences for coolwatcher sudo apt install build-essential libqt4-qt3support itcl3 itk3 iwidgets4 and maybe other compatible libs in ther latest ubuntu sudo apt install libpng12-0 libusb-0.1-4 CSDTK set up Create a project folder e.g. ~/projects mkdir ~/projects Decompress CSDTK42_Linux.tar.gz to a folder, ~/software/CSDTK for example, and then execute setup.sh, the first parameter is the location of CSDTK, the second parameter is the location of your projects cd ~/software tar -xzvf CSDTK42_Linux.tar.gz cd CSDTK ./setup.sh ./ ~/projects Compile Decompress the CSDK downloaded to GPRS_C_SDK folder into a directory, such as ~/projects/GPRS_C_SDK, use the underscore(_) instead of minus(-). Check if the SDK have full files, check platform/csdk folder, if no debug and release folders, you download the wrong SDK file, please download again in release page or clone by command git clone https://github.com/Ai-Thinker-Open/GPRS_C_SDK.git --recursive compile cd ~/projects/GPRS_C_SDK ./build.sh demo gpio if you put you GPRS project in the projects folder(you set by command ./setup.sh ./ ~/projects before), you can use a script to go to the project folder quikly as follow work GPRS_C_SDK ./build.sh demo gpio Then you can use ./build.sh script to build project: ./build.sh $PROJ:compile app module，e.g.:./build.sh app to compile the source code of app folder ./build.sh demo $PROJ:compile demo project, e.g.:./build.sh demo gpio to compile gpio demo ./build.sh clean $PROJ:clear the build files of $PROJ ./build.sh clean all:clear all the build files ./build.sh demo $PROJ release:build a release version, e.g.:./build.sh demo gpio release，if the last parameter is not release, it will be default to debug version. The GDB can be used to debug errors after system crashed in debug version, but release version can not, watch dog activate in release version,it will auto restart system when system crashed! e.g.: ./build.sh demo gpio A build folder will be generated after compile, there's two *.lod files in th hex folder, it's the target file that burn(download) to dev board about target hex file(*.lod) There's two hex file,(*_B*.lod and *_flash.lod), you must burn the bigger one to dev board at the first time, then you can just burn the little one to reduce the doanload time. And you must download the bigger if you update the SDK version Other Problems If error occured, please compare the documents carefully to see if the operation is wrong，and find in issue Way A: github add issue Way B: Ai-Thinker forum "},"c-sdk/installation_docker.html":{"url":"c-sdk/installation_docker.html","title":"Installation Docker","keywords":"","body":"Docker compile environment Docker build environment for Ai-Thinker A9/A9G (RDA8955) We can do more awsome works by docker image, e.g. Set up build evironment faster and easier without affecting the host (physical machine/PC) environment Make automatic testing/build easier See here to start "},"c-sdk/burn-debug.html":{"url":"c-sdk/burn-debug.html","title":"Burn & Debug","keywords":"","body":"GPRS Burn(Download) and Debug hardware connection Module Debugging The download interface is the HST interface. The pinsHST_RX and HST_TX are respectively connected to theTX and RX pins of the USB to serial module (cross connection,HST_RX then TX) The power can be connected to the lithium battery voltage (ie 3.8v ~ 4.2v) (VBAT pin), can also be connected to 5v power supply (5v input pin or USB input), it should be noted that, if using lithium battery power supply You need to press POWER KEY for about 3 seconds to power on the module, USB power will automatically power on the power. In the download or debugging to ensure that has been switched on. Linux Install dependences sudo apt install build-essential libqt4-qt3support itcl3 itk3 iwidgets4 Create a link file for serial port as follow, and later you can fill in the coolwatcher's chart with 1,the COM1 must upper-case sudo ln -s /dev/ttyUSB0 comport/COM1 Then double click coolwatcher to run software Download steps Update coolwatcher to the latest version(coolwatcher is in the CSDTK folder) OpenCSDTK/cooltools/coolwatcher.exe or CSDTK/cooltools/coolwatcher in Linux Select the 8955 for the options on the left, and fill the lastcomport chart with port number of HOST serial (HST) for the connection module. Then click ok Wait for the connection to succeed, the following screen appears If there is a connection failure, please refer to [coolwatcher can not connect reason] (#coolwatcher can not connect) part If first time open coolwatcher, click DRY icon，select the file whose name contains 8955 ramrun spi32m .lod,（onder project platform/ramrun or coolwatcher's cooltools\\chipgen\\Modem2G\\toolpool\\plugins\\fastpf\\flash_programmers folder）。 Only need to set once, will remember later. Click lod icon, select fimware(.lod) in the hex folder in the GPRS project, There's two hex file,(`_B.lodand_flash.lod`), you must burn the bigger one to dev board at the first time, then you can just burn the little one to reduce the doanload time. And you must download the bigger if you update the SDK version. Click download icon to download, then progress bar can be find in the right corner if burn fail,refer to coolwatcher Download Fail sectioin. Coolwatcher Connect Fail Solutions: Ensure that the serial port and the module are connected (note that the USB port on the development board is not a serial port, and the serial port is connected to the HST_RX andHST_TX pins through the USB to serial port module) Ensure that the serial port is not occupied by other software Check the serial number is wrong, set the serial number when restarting, or do not restart click the lower right corner CoolHost icon to set Then click connect to reconnect the serial port Coolwatcher Download Fail ramrun file error, try using project directory platform / ramrun and coolwatcherCSDTK\\cooltools\\chipgen\\Modem2G\\toolpool\\plugins\\fastpf\\flash_programmers directory *_8955_*_spi32m_ramrun.lod It is possible that the program has entered sleep mode and is reset by the module reset button before downloading Serial port may be lost, the lower right corner of the taskbar double-click the CoolHost icon to reconnect the serial port, and then download Serial port other problems, unplug the USB to serial port module re-insert the computer, and then re-connect the serial port Boot into the program into the sleep mode or thread using the while (1) dead loop and completely take up resources, such as: void LoopTask(VOID *pData) { uint64_t count = 0; while(1) { ++count; if(count == 3000) { count = 0; Trace(1,\"Test Test\"); } } } Solution: Press the module reset button, the USB transfer serial port module data transmission indicator flashing (that is, the module has been started and send data to the serial port) press the download button for a second, not to try on how many times In order to completely prevent this problem, it is recommended not to write such a program, it is best to use the time in the loop trigger or delay at least OS_Sleep ()) void LoopTask (VOID * pData) { uint64_t count = 0; while (1) { ++ count; if (count == 3000) { count = 0; Trace (1, \"Test Test\"); OS_Sleep (100); } } } or void LoopTask (VOID * pData) { uint64_t count = 0; while (1) { ++ count; if (count == 3000) { count = 0; Trace (1, \"Test Test\"); } } OS_Sleep (1); } Or event handling void AppMainTask (VOID * pData) { API_Event_t * event = NULL; while (1) { if (OS_WaitEvent (mainTaskHandle, & event, OS_TIME_OUT_WAIT_FOREVER)) { EventDispatch (event); OS_Free (event-> pParam1); OS_Free (event); } } } Debug Log Tool: Tracer View debug information: Open Plugins-> Active Tracer, the interface and function as shown below Need to set up Tracer before use, set as follows 1 ~ 6 steps: The program needs to output the debugging information You can call Trace (uint16_t nIndex, PCSTR fmt, ...) in api_debug.h, wherenIndex corresponds to MMI 01 ~MMI 16 Tracer Problems Sometimes I expect the debug data is not displayed, it may be the upper right corner of the pause to display the latest button, forgot to turn off! ! Tracer may not power on when system just power on, some early info may can not diaply Crash handling Here simulated an exception, null pointer assignment exception, the general emergence of such problems are the problem of indiscriminate flight! Open GBD, and set the select elf file Open the GBD terminal and enter bt orbt f to view the message It should be noted that this GDB does not support set break point with this software(coolwatcher), break point only can be set in the code. See more problems in issue "},"c-sdk/first-code.html":{"url":"c-sdk/first-code.html","title":"First Code","keywords":"","body":"Start My First Code To ensure that you can compile code, Download firmware to GPRS module / development board, then we can begin our first code ~ ~ The following code can be found in the demo/first directory Let's code from Hello word So our goal: a complete code structure, and can print Hello GPRS continuously. Contents Contents Description app application code here build build files demo examples doc SDK-related documentation hex last generated burnable file(burn files) include SDK api include directory init system initialization directory, you can ignore, do not recommend edit platform lib files Setting up folders and files Create a new demo/fisrt folder and create a new Makefile file Fill in the following contents: # Name of the module LOCAL_NAME := demo/first # List of submodules which contain code we need to include in the final lib LOCAL_API_DEPENDS := \\ LOCAL_ADD_INCLUDE := include\\ include/std_inc \\ include/api_inc \\ # Set this to any non-null string to signal a module which # generates a binary IS_ENTRY_POINT := no ## ------------------------------------ ## ## Add your custom flags here ## ## ------------------------------------ ## MYCFLAGS += ## ------------------------------------- ## ## List all your sources here ## ## ------------------------------------- ## C_SRC := ${notdir ${wildcard src/*.c}} ## ------------------------------------- ## ## Do Not touch below this line ## ## ------------------------------------- ## include ${SOFT_WORKDIR}/platform/compilation/cust_rules.mk LOCAL_NAME := demo/first is folder path,LOCAL_ADD_INCLUDE is header path setting up demo/first/src folder and set up demo_first.c file Code Code can be find in demo/first/src/demo_first.c The main thing to do is to write the program entry and create the main task to receive events from the bottom, and to create a task and print information continuously. Entrance and main task Program entry, create the main task #include \"stdbool.h\" #include \"stdint.h\" #include \"api_os.h\" #include \"api_debug.h\" #include \"api_event.h\" #define MAIN_TASK_STACK_SIZE (2048 * 2) #define MAIN_TASK_PRIORITY 0 #define MAIN_TASK_NAME \"Main Test Task\" static HANDLE mainTaskHandle = NULL; void first_Main(void) { mainTaskHandle = OS_CreateTask(MainTask, NULL, NULL, MAIN_TASK_STACK_SIZE, MAIN_TASK_PRIORITY, 0, 0, MAIN_TASK_NAME); OS_SetUserMainHandle(&mainTaskHandle); } void first_Main(void) is the main entrance,no parameters and no return value,，The left side of the underline must be the name of the folder, here is \"first\", the right of the underline must be \"Main\". Call OS_CreateTask to create a task. The meaning of the specific parameters can be seen in the OS part. Call OS_SetUserMainHandle to pass the newly created task pointer(Handler) to lower system, this is necessary Primary task processing and printing tasks #define SECOND_TASK_STACK_SIZE (2048 * 2) #define SECOND_TASK_PRIORITY 1 #define SECOND_TASK_NAME \"Second Test Task\" static HANDLE secondTaskHandle = NULL; void SecondTask(void *pData) { while(1) { Trace(1,\"Hello GPRS \"); OS_Sleep(3000); } } void EventDispatch(API_Event_t* pEvent) { switch(pEvent->id) { default: break; } } void MainTask(void *pData) { API_Event_t* event=NULL; secondTaskHandle = OS_CreateTask(SecondTask, NULL, NULL, SECOND_TASK_STACK_SIZE, SECOND_TASK_PRIORITY, 0, 0, SECOND_TASK_NAME); while(1) { if(OS_WaitEvent(mainTaskHandle, (void**)&event, OS_TIME_OUT_WAIT_FOREVER)) { EventDispatch(event); OS_Free(event->pParam1); OS_Free(event->pParam2); OS_Free(event); } } } In the main task MainTask, a new task SecondTask is created, and what it does in this task is to print a Hello GPRS every 3 seconds, and the print information can be seen in the tracer tool of coolwatcher. Then the main task blocks waiting for events from the lower system, and is handled in the EventDispatch function, where no event is handled for the time being, all events can be found in the api_event.h, and the parameters of each event are also annotated. Compiling and downloading firmware to verify Download to the development board according to the previous compile and download documentation then we can find Hello GPRS in the tracer tool "},"c-sdk/code-style.html":{"url":"c-sdk/code-style.html","title":"Code Style","keywords":"","body":"Code Style And Directory Structure Directory Structure It is composed mainly of the following folders: app: user app folder demo: examples include: header files init: initilize code, do not edit platform: lib files You can find API in include folder, and examples in demo folder. All the event and it's parameters description from lower system can be find in api_event.h Coding Style A unified code style and convenient reading is very important for any code, each person's code style is different, but many people must have a unified style when developing the same project, and a simple and clean code will make the code more smooth and easy. CSDK uses a unified code style to briefly summarize the following points: Function naming Module API uses a \"upper case function module name\"+\"_\"+\"Upper Camel Case\",\" such as AUDIO_MicOpen, SSL_Init; the ordinary function is named with Upper-Camel-Case, such as EventDispatch. entry function is special, use the folder name _Main, for example,imei_Main`. Variable naming Lower camel case, e.g.:int ballNumber; Macro definition Upper case with\"_\", e.g.: #define BUFFER_MAX_LENGTH 10 File Encoding Format File use UTF-8 with no BOM format Tab Or Space Use 4 space instead of tab Word abbreviation use acronyms for some well-known words in the industry, such as src, tmp,addr, etc. in addition to this, in order to ensure the readability of the code, be sure to use the full name, especially some professional terms, to make the person without contact with the word search the meaning of the word through the search engine. For example, NetworkLocation, if abbreviated to NL, NetLo, believe that even people who are very familiar with the word have to look at the context of the code to get the meaning of it slowly! If you search these abbreviations on the Internet, you never get NetworkLocation! so, in order to make the code more concise and easy to read, it is not necessarily to make the code words abbreviated to a simpler form, but the opposite is that the full-name words are often more readable. In addition, some words need to be interpreted and appropriate comments should be made. Comment annotations can be used with / / \\ \"or / / \\\" to annotate, and invalid code should be used as / ( / \\ \"notes) as far as possible. User /**/ or // to comment code, and invalid code should be comment with /**/ as far as possible. If we want some comment added to auto generated documentation, use: ////////////// ///comment here ////////////// of /** *comment here * */ And add some infomation to file or function, e.g. file: /** *@file header.h *@author nick name */ or function /** *@brief brief, @brief can be omitted *@param a parameter a *@param b parameter b *@return return sum */ "},"c-sdk/function-api.html":{"url":"c-sdk/function-api.html","title":"Function & API","keywords":"","body":"Function and API examples of module in demo folder, you can compile them and burn to dev-board to test. "},"c-sdk/function-api/gpio.html":{"url":"c-sdk/function-api/gpio.html","title":"GPIO","keywords":"","body":"GPIO (General Purpose Input Output)通用输入输出接口 Open power of GPIO first before config GPIO bool PM_PowerEnable(Power_Type_t powerType, bool isOn) ```c 函数来打开对应的IO口电源,不同IO口对应的电源如下： ```c typedef enum{ POWER_TYPE_VPAD = 0, // GPIO0 ~ GPIO7 and GPIO25 ~ GPIO36 2.8V //always on POWER_TYPE_MMC, // GPIO8 ~ GPIO13 1.9V POWER_TYPE_LCD, // GPIO14 ~ GPIO18 1.9V POWER_TYPE_CAM, // GPIO19 ~ GPIO24 1.9V POWER_TYPE_MAX }Power_Type_t; 比如： Use GPIO5, call PM_PowerEnable(POWER_TYPE_VPAD,true); Use I2C2, we should config IO19 and IO20, so call PM_PowerEnable(POWER_TYPE_CAM,true); In addition to the general IO function, some of the pins also have multiplexing functions. Example:CSDK demo/gpio Enumerated type GPIO_PIN GPIO Pins typedef enum{ GPIO_PIN0 = 0, //IO 可中断 GPIO_PIN1, //IO 可中断 GPIO_PIN2, //IO 可中断 GPIO_PIN3, //IO 可中断 GPIO_PIN4, //IO 可中断 GPIO_PIN5, //IO 可中断 GPIO_PIN6, //IO 可中断 GPIO_PIN7, //IO 可中断 GPIO_PIN8, GPIO_PIN9, GPIO_PIN10, GPIO_PIN11, GPIO_PIN12, GPIO_PIN13, GPIO_PIN14, GPIO_PIN15, GPIO_PIN16, GPIO_PIN17, GPIO_PIN18, GPIO_PIN19, GPIO_PIN20, GPIO_PIN21, GPIO_PIN22, GPIO_PIN23, GPIO_PIN24, GPIO_PIN25, GPIO_PIN26, GPIO_PIN27, GPIO_PIN28, GPIO_PIN29, GPIO_PIN30, GPIO_PIN31, GPIO_PIN32, GPIO_PIN33, GPIO_PIN34, GPIO_PIN_MAX }GPIO_PIN; GPIO_MODE IO mode typedef enum{ GPIO_MODE_OUTPUT = 0, GPIO_MODE_INPUT, GPIO_MODE_INPUT_INT, // interrupt mode GPIO_MODE_MAX }GPIO_MODE; GPIO_LEVEL gpio level typedef enum{ GPIO_LEVEL_LOW = 0, GPIO_LEVEL_HIGH = 1 }GPIO_LEVEL; GPIO_INT_TYPE Interrupt type typedef enum { GPIO_INT_TYPE_HIGH_LEVEL = 0, GPIO_INT_TYPE_LOW_LEVEL, GPIO_INT_TYPE_RISING_EDGE, GPIO_INT_TYPE_FALLING_EDGE, GPIO_INT_TYPE_RISING_FALLING_EDGE, GPIO_INT_TYPE_MAX }GPIO_INT_TYPE; Struct GPIO_INT_callback_param_t interrupt callbak parameter type typedef struct{ GPIO_PIN pin; }GPIO_INT_callback_param_t; PCallbackINT Interrupt callback type typedef void (*PCallbackINT)(GPIO_INT_callback_param_t* param); GPIO_INT_config_t Interrupt configuration typedef struct{ uint16_t debounce; //去抖时间（ms） GPIO_INT_TYPE type ; PCallbackINT callback; }GPIO_INT_config_t; GPIO_config_t GPIO configuration typedef struct{ GPIO_PIN pin ; GPIO_MODE mode ; GPIO_LEVEL defaultLevel; GPIO_INT_config_t intConfig ; }GPIO_config_t; Function Interface GPIO_Init bool GPIO_Init(GPIO_config_t config); Brief Initialize GPIO Parameters config：GPIO configuration Return bool：config success or fail GPIO_GetConfig void GPIO_GetConfig(GPIO_PIN pin,GPIO_config_t* config); Brief Get GPIO configuration Parameters config：GPIO config Return GPIO_SetLevel bool GPIO_SetLevel(GPIO_config_t gpioConf, GPIO_LEVEL level); Brief Config GPIO output level Parameters gpioConf：GPIO init configuration variable level: high or low level Return bool： is set success GPIO_Set bool GPIO_Set(GPIO_PIN pin, GPIO_LEVEL level); Brief Setting the GPIO level is just like the GPIO_SetLevel function, but the parameters are different. Parameters pin:GPIO pin level: high or low level Return bool: set success or not GPIO_GetLevel bool GPIO_GetLevel(GPIO_config_t gpioConf, GPIO_LEVEL* level); Brief Get level of GPIO Parameters gpioConf:GPIO init configuratioin variable level: level of GPIO Return bool：Is get success GPIO_Get bool GPIO_Get(GPIO_PIN pin, GPIO_LEVEL* level); Brief Get GPIO level, the same function with GPIO_GetLevel, but parameter not the same Parameters pin:GPIO pin level: level of GPIO Return bool：Is get success GPIO_Close bool GPIO_Close(GPIO_PIN pin); Brief Close GPIO and release resources of GPIO Parameters pin:GPIO pin Return bool：Is close success "},"c-sdk/function-api/adc.html":{"url":"c-sdk/function-api/adc.html","title":"ADC","keywords":"","body":"ADC A9/A9G have two 10 bits ADC interface, 0~1.8V voltage can be measured example: demo/adc Enumerated type ADC_Channel_t ADC channel,ADC0 and ADC1 typedef enum { ADC_CHANNEL_0 = 0 , ADC_CHANNEL_1 , ADC_CHANNEL_MAX }ADC_Channel_t; ADC_Sample_Period_t ADC sample rate typedef enum { ADC_SAMPLE_PERIOD_122US = 0 , ADC_SAMPLE_PERIOD_1MS , ADC_SAMPLE_PERIOD_10MS , ADC_SAMPLE_PERIOD_100MS , ADC_SAMPLE_PERIOD_250MS , ADC_SAMPLE_PERIOD_500MS , ADC_SAMPLE_PERIOD_1S , ADC_SAMPLE_PERIOD_2S , ADC_SAMPLE_PERIOD_MAX } ADC_Sample_Period_t;//Acquisition Time Period Struct ADC_Config_t ADC config info, include channel and sample rate typedef struct { ADC_Channel_t channel; ADC_Sample_Period_t samplePeriod; }ADC_Config_t; Function ADC_Init void ADC_Init(ADC_Config_t adcConfig); Function 初始化ADC Parameters adcConfig：ADC config infomation Return None ADC_Read bool ADC_Read(ADC_Channel_t channel, uint16_t* value, uint16_t* mV); Function Read ADC value, value in 0~1023, voltage in 0~1.8v Parameters channel:ADC channel value: the value read mV: the voltage value read Return bool：read success or not ADC_Close void ADC_Close(ADC_Channel_t channel); Function 关闭ADC定期采样，当所有通道关闭后会释放ADC硬件资源 Close ADC, release ADC resources when all channel are closed Parameters channel:ADC channel Return None "},"c-sdk/function-api/uart.html":{"url":"c-sdk/function-api/uart.html","title":"UART","keywords":"","body":"UART (Serial port) The module has three UART, serial port 1, serial port 2 and download and debug serial HST serial port. example:demo/uart Enumerated type UART_Port_t Port id typedef enum{ UART1 = 1, UART2 = 2, UART_GPS = 2, UART_PORT_MAX }UART_Port_t; UART_Baud_Rate_t Baud rate typedef enum{ UART_BAUD_RATE_1200 = 1200, UART_BAUD_RATE_2400 = 2400, UART_BAUD_RATE_4800 = 4800, UART_BAUD_RATE_9600 = 9600, UART_BAUD_RATE_14400 = 14400, UART_BAUD_RATE_19200 = 19200, UART_BAUD_RATE_28800 = 28800, UART_BAUD_RATE_33600 = 33600, UART_BAUD_RATE_38400 = 38400, UART_BAUD_RATE_57600 = 57600, UART_BAUD_RATE_115200 = 115200, UART_BAUD_RATE_230400 = 230400, UART_BAUD_RATE_460800 = 460800, UART_BAUD_RATE_921600 = 921600, UART_BAUD_RATE_1300000 = 1300000, UART_BAUD_RATE_1625000 = 1625000, UART_BAUD_RATE_2166700 = 2166700, UART_BAUD_RATE_3250000 = 3250000, UART_BAUD_RATE_MAX = 3250001 }UART_Baud_Rate_t; UART_Data_Bits_t Data bits typedef enum{ UART_DATA_BITS_7 = 7, UART_DATA_BITS_8 = 8, UART_DATA_BITS_MAX }UART_Data_Bits_t; UART_Stop_Bits_t Stop bits typedef enum{ UART_STOP_BITS_1 = 1, UART_STOP_BITS_2 , UART_STOP_BITS_MAX }UART_Stop_Bits_t; UART_Parity_t Parity typedef enum{ UART_PARITY_NONE = 0, UART_PARITY_ODD , UART_PARITY_EVEN , UART_PARITY_SPACE , UART_PARITY_MARK , UART_PARITY_MAX }UART_Parity_t; UART_Error_t Error code typedef enum{ UART_ERROR_RX_LINE_ERROR, UART_ERROR_RX_OVER_FLOW_ERROR, UART_ERROR_RX_PARITY_ERROR, UART_ERROR_RX_BREAK_INT_ERROR, UART_ERROR_RX_FRAMING_ERROR, UART_ERROR_TX_OVER_FLOW_ERROR, UART_ERROR_MAX }UART_Error_t; Struct UART_Callback_Param_t Callback function parameter typedef struct{ UART_Port_t port; uint32_t length; char *buf;//the receive buf }UART_Callback_Param_t; UART_Config_t Serial initialization parameters typedef struct{ UART_Baud_Rate_t baudRate; UART_Data_Bits_t dataBits; UART_Stop_Bits_t stopBits; UART_Parity_t parity; UART_Callback_t rxCallback; UART_Error_Callback_t errorCallback; bool useEvent; }UART_Config_t; Function UART_Callback_t typedef void (*UART_Callback_t)(UART_Callback_Param_t param); Function Serial callback function, defined by the user Parameters param：callback parameters Return None UART_Error_Callback_t typedef void (*UART_Error_Callback_t)(UART_Error_t error); Function Serial error callback function, defined by the user Parameters error：error info Return None UART_Init bool UART_Init(UART_Port_t uartN, UART_Config_t config); Function Initialize UART Parameters uartN: uart id config: uart configuration Return bool:Initialize success or not UART_Write uint32_t UART_Write(UART_Port_t uartN, uint8_t* dataToWrite, uint32_t length); Function Send data to UART Parameters uartN: UART id dataToWrite: data to write length: data length Return Successfully written to the length of the serial port UART_Read uint32_t UART_Read(UART_Port_t uartN, uint8_t* dataToRead, uint32_t length, uint32_t timeOutMs); Function Reading data from the serial port Parameters uartN: serial number the location of the data stored by the dataToWrite: read the length of the data to be read by length: timeOutMs: timeout time, the unit is milliseconds Return Data length read successfully from serial port UART_Close bool UART_Close(UART_Port_t uartN); Function Close UART Parameters uartN: id Return Close success or not "},"c-sdk/function-api/os.html":{"url":"c-sdk/function-api/os.html","title":"OS","keywords":"","body":"操作系统(OS) A lightweight operating system that includes basic task operations, message mechanisms, and so on. example: demo/os Macro definition OS_WAIT_FOREVER Timeout time special value, blocking wait (always waiting) #define OS_WAIT_FOREVER 0xFFFFFFFF OS_NO_WAIT Timeout time special value, not waiting #define OS_NO_WAIT 0x0 OS_EVENT_PRI_NORMAL Event priority is common, the value of nOption parameter of OS_SendEvent. #define OS_EVENT_PRI_NORMAL 0 OS_EVENT_PRI_URGENT Event priority is urgent, the value of nOption parameter of OS_SendEvent. #define OS_EVENT_PRI_URGENT 1 OS_CREATE_DEFAULT The value of the nCreationFlags parameter of the function OS_CreateTask indicates that the task is automatically started after the creation of the task. #define OS_CREATE_DEFAULT 0 OS_CREATE_SUSPENDED The value of the nCreationFlags parameter of the function OS_CreateTask indicates that the task is not automatically started after the creation of the task. #define OS_CREATE_SUSPENDED 1 Struct OS_Heap_Status_t Heap status, including the total size and the size that has been used. typedef struct{ uint32_t usedSize; uint32_t totalSize; }OS_Heap_Status_t; Function PTASK_FUNC_T typedef void (*PTASK_FUNC_T)(PVOID pParameter); Function The created task master function, defined by the user Parameters pParameter:Parameters passed in when this function is called Return None OS_SetUserMainHandle void OS_SetUserMainHandle(HANDLE* appMainHandle); Function The primary task is set up. The primary task is used to receive messages from the bottom. This function must be called immediately after the main task is created when the machine is started, otherwise the underlying layer can not be released to the application layer. Parameters appMainHandle:The pointer returned by the created primary task (handle) Return None OS_CreateTask HANDLE OS_CreateTask( PTASK_FUNC_T pTaskEntry, PVOID pParameter, PVOID pStackAddr, UINT16 nStackSize, UINT8 nPriority, UINT16 nCreationFlags, UINT16 nTimeSlice, PCSTR pTaskName); Function Create a new task Parameters pTaskEntry: task execution function, PTASK_FUNC_T type pParameter: needs to be passed to the parameters of the execution function pStackAddr: custom stack address, temporarily does not support custom, that is, the value can only be `NULL '. nStackSize: stack size nPriority: task priority, >=0, the priority of each task is different, the smaller the value, the larger the task priority. nCreationFlags: OS_CREATE_DEFAULT/0: by default, the task is started after the task is created; OS_CREATE_SUSPENDED: the task is not executed after the task is created, and the start function is required to be invoked manually to open the task nTimeSlice: reservation, value 0 pTaskName: task name Return A pointer to the task created (handle), if the creation of a task fails, it returns NULL. OS_StartTask void OS_StartTask( HANDLE pHTask, PVOID pParameter); Function Start the execution of the task Parameters pHTask: task handle, return value of OS_CreateTask. pParameter: needs to pass to the parameter of the task function Return None OS_StopTask void OS_StopTask( HANDLE pHTask); Function Stop task execution Parameters pHTask: task handle, return value of OS_CreateTask. Return None OS_DeleteTask bool OS_DeleteTask( HANDLE hTask); Function Delete task Parameters hTask: task handle, return value of OS_CreateTask Return delete whether the task is successful or not OS_SuspendTask bool OS_SuspendTask( HANDLE hTask); Function Hang up thread Parameters hTask: task handle, return value of OS_CreateTask Return whether to hang up or not OS_ResumeTask bool OS_ResumeTask( HANDLE hTask); Function Continue the task Parameters hTask: task handle, return value of OS_CreateTask Return whether or not it is successful OS_Sleep bool OS_Sleep(UINT32 nMillisecondes); Function Blocking millisecond delay Parameters nMillisecondes: blocking delay time per unit millisecond Return whether or not it is successful (always true) OS_SleepUs void OS_SleepUs(UINT32 us); Function Blocking subtlety delay Parameters us: delay time, unit subtlety Return None OS_WaitEvent bool OS_WaitEvent( HANDLE hTask, PVOID* pEvent, UINT32 nTimeOut); Function Blocking wait event Parameters hTask: task handle, return value of OS_CreateTask pEvent: event value, parameters from OS_SendEvent nTimeOut: is waiting for the timeout time. At present, it only supports blocking wait. The value must be OS_WAIT_FOREVER. Return successful waiting for the event OS_SendEvent bool OS_SendEvent( HANDLE hTask, PVOID pEvent, UINT32 nTimeOut, UINT16 nOption); Function Send an event to a task Parameters hTask: task handle, return value of OS_CreateTask data sent by the pEvent: event (pointer) nTimeOut: timeout time, currently supporting blocking wait only, the value must be OS_WAIT_FOREVER. nOption: event option, OS_EVENT_PRI_NORMAL: general priority, OS_EVENT_PRI_URGENT: emergency priority. Return whether the event was sent to success OS_ResetEventQueue bool OS_ResetEventQueue( HANDLE hTask); Function Reset the event queue Parameters Reset event queue * hTask: task handle, return value of OS_CreateTask. Return whether to reset the success OS_IsEventAvailable bool OS_IsEventAvailable( HANDLE hTask); Function Judge whether or not a task has an event to be received Parameters hTask: task handle, return value of OS_CreateTask Return whether there is an event to be received OS_Malloc PVOID OS_Malloc (UINT32 nSize); Function Dynamically allocated memory Parameters nSize: dynamically allocates memory length, the unit is bytes Return dynamically allocate the first address of the memory block. If the allocation fails, it will return to NULL. OS_Realloc PVOID OS_Realloc(VOID *ptr, UINT32 nSize); Function Redistribution of memory Parameters ptr: dynamically allocated memory block first address nSize: new dynamically allocated memory block length Return the first address of the memory block allocated successfully. If NULL, the allocation fails. OS_Free bool OS_Free (PVOID pMemBlock); Function Release dynamically allocated memory Parameters pMemBlock: dynamically allocated memory block first address Return whether to release success or not OS_GetHeapUsageStatus bool OS_GetHeapUsageStatus(OS_Heap_Status_t* pOsHeapStatus); Function Get the use of the heap Parameters pOsHeapStatus: reactor usage Return whether to get heap status success OS_CreateSemaphore HANDLE OS_CreateSemaphore( UINT32 nInitCount // Specify the initial count of the semaphore ); Function Create a semaphore Parameters nInitCount: semaphore initialization value, 0 indicates that the resource is occupied, n indicates that there are n resource values, each wait will wait for the value of the resource and reduce one, and the release operation will add the value of the resource to one 返回值 semaphore handle, if failed, return to NULL OS_DeleteSemaphore bool OS_DeleteSemaphore( HANDLE hSem); Function Deleting the semaphore Parameters hSem: semaphore handle, return value of OS_CreateSemaphore. Return whether the signal is deleted or not OS_WaitForSemaphore bool OS_WaitForSemaphore( HANDLE hSem, // Specify the handle to a counting semaphore UINT32 nTimeOut // the time-out value ); Function Wait for the semaphore to know that the resource value is greater than 0 and reduce the resource value. Parameters hSem: semaphore handle, return value of OS_CreateSemaphore. nTimeOut: timeout value, temporarily reserved, or OS_WAIT_FOREVER Return whether the amount of signal (resource value) is successfully obtained OS_ReleaseSemaphore bool OS_ReleaseSemaphore( HANDLE hSem //Specify the counting semaphore ); Function Release the semaphore, that is, the value of the resource plus one Parameters hSem: semaphore handle, return value of OS_CreateSemaphore. Return whether to release the signal (resource value) success OS_CreateMutex HANDLE OS_CreateMutex(void); Function Create a mutual exclusion Parameters None Return mutex handle, if failed, return to NULL OS_DeleteMutex void OS_DeleteMutex(HANDLE mutex); Function Deleting mutual exclusion Parameters mutex: mutual exclusion handle, return value of OS_CreateMutex. Return None OS_LockMutex void OS_LockMutex(HANDLE mutex); Function Lock mutual exclusion, that is, occupying resources Parameters mutex: mutual exclusion handle, return value of OS_CreateMutex. Return None OS_UnlockMutex void OS_UnlockMutex(HANDLE mutex); Function Release mutual exclusion, that is, release resources Parameters mutex: mutual exclusion handle, return value of OS_CreateMutex. Return None OS_CALLBACK_FUNC_T typedef void (*OS_CALLBACK_FUNC_T)(void* param); Function Callback function, defined by the user Parameters param: User incoming parameters Return None OS_StartCallbackTimer bool OS_StartCallbackTimer(HANDLE hTask, UINT32 ms, OS_CALLBACK_FUNC_T callback, void* param); Function Start the software timer and set the callback function when the time is set. Parameters hTask: task handle, which must include OS_WaitEvent function call (for example, the main task), otherwise the callback will not be triggered. ms: timing time callback: callback function param: passes the parameters of the callback function Return to create a timer success OS_StopCallbackTimer bool OS_StopCallbackTimer(HANDLE hTask, OS_CALLBACK_FUNC_T callback, void *param); Function Stop the software timer Parameters hTask: task handle, which must include OS_WaitEvent function call (for example, the main task), otherwise the callback will not be triggered. callback: callback function param: passes the parameters of the callback function Return cessation of the success of the timer OS_QueryCallbackTimer uint32_t OS_QueryCallbackTimer(HANDLE hTask, OS_CALLBACK_FUNC_T callback, void *param); Function How much time is left to end the query software timer Parameters hTask: task handle, which must include OS_WaitEvent function call (for example, the main task), otherwise the callback will not be triggered. callback: callback function param: passes the parameters of the callback function Return the timer is out of the rest of the time "},"c-sdk/function-api/imei.html":{"url":"c-sdk/function-api/imei.html","title":"IMEI","keywords":"","body":"IMEI IMEI is a string of 15 bytes in length. Each module corresponds to the only IMEI number. When the factory is produced, it is printed on the module shell and exists in the form of two-dimensional code. It can be scanned by the mobile phone to get the two-dimensional code and can be obtained by the API function. example:demo/imei Function INFO_GetIMEI bool INFO_GetIMEI(uint8_t* pImei); Function Get IMEI of module Parameters pImei:IMEI read, length >=15 bytes Return Get IMEI success or not "},"c-sdk/function-api/iccid.html":{"url":"c-sdk/function-api/iccid.html","title":"ICCID","keywords":"","body":"ICCID(Integrate circuit card identity ) ICCD is the unique identification of the SIM card with a length of 20. example:demo/iccid Function SIM_GetICCID bool SIM_GetICCID(uint8_t* iccid); Function Get the ICCID value of the SIM card Parameters iccid：The location of the obtained iccid value storage, the length of the array should >= 20 Return Whether the ICCID value is successfully acquired or not, if not please check if the card is inserted. "},"c-sdk/function-api/gps.html":{"url":"c-sdk/function-api/gps.html","title":"GPS","keywords":"","body":"GPS Get satellite positioning information, GPS chip connected with GPRS chip through UART2 internally, so UART 2 will receive GPS NMEA data if GPS open example:demo/gps Note: when using the positioning coordinates on the map, notice the conversion of coordinates, the location of the module output is WGS84 coordinates, if the Baidu map is used, it needs to be converted into BD-09 coordinates, if the Tencent map or Google map and so on, please convert to GCJ-02 coordinates (Mars coordinates) first, or otherwise display The result may be a huge error. The original information format for GPS output is NMEA standard, such as the coordinate (2236.3934,11350.3831) representation (22° 36.3934′, 113°50.3831′), conversion degree: (22.606557°, 113.839718°), this is the WGS84 coordinate, and then copy to the map view tool to see the position in the map. Function GPS_Open bool GPS_Open(UART_Callback_t gpsReceivedCallback); Function Open GPS power, GPS start work Parameters gpsReceivedCallback：Serial callback function, if set to NULL, the receipt of the serial port 2 received GPS data will not produce a callback, but the data of the GPS is sent to the main task in the way of events; if not for NULL, it will not produce an event, the set of serial callback function will be called, do not consume too much time in the processing function. It is suggested that the way of the event be used, refer to the GPS demo. Return Is open GPS success GPS_Close bool GPS_Close(); Function Close GPS power Parameters None Return Is close GPS success "},"c-sdk/function-api/iic.html":{"url":"c-sdk/function-api/iic.html","title":"I2C","keywords":"","body":"I2C A9/A9G has three I2C interfaces. When using it, pay attention to which pins are multiplexed and pin view the pin diagram of pudding development board. And open power first Only support the master mode example:demo/i2c Macro definition I2C_DEFAULT_TIME_OUT default timeout time #define I2C_DEFAULT_TIME_OUT 10 //10ms Enumerated type I2C_ID_t I2C ID typedef enum { I2C1 = 1 , I2C2 = 2 , I2C3 = 3 , I2C_ID_MAX } I2C_ID_t; I2C_FREQ_t I2C frequency typedef enum { I2C_FREQ_100K, I2C_FREQ_400K, I2C_FREQ_MAX } I2C_FREQ_t; I2C_Error_t I2C error information typedef enum{ I2C_ERROR_NONE = 0 , /// A resource reset is required I2C_ERROR_RESOURCE_RESET, /// An attempt to access a busy resource failed I2C_ERROR_RESOURCE_BUSY, /// Timeout while trying to access the resource I2C_ERROR_RESOURCE_TIMEOUT, /// An attempt to access a resource that is not enabled I2C_ERROR_RESOURCE_NOT_ENABLED, /// Invalid parameter I2C_ERROR_BAD_PARAMETER, /// Communication failure I2C_ERROR_COMMUNICATION_FAILED = 14, I2C_ERROR_MAX } I2C_Error_t; I2C_CMD_Mask_t The I2C flag bit, the function of the Function with Raw typedef enum{ I2C_CMD_MASK_MASTER_NACK = (1 Struct I2C_Config_t I2C configuration typedef struct{ I2C_FREQ_t freq; } I2C_Config_t; Function I2C_Init bool I2C_Init(I2C_ID_t i2c, I2C_Config_t config); Function Initialize I2C Parameters i2c：I2C ID config：I2C initialize configuration Return Is success to config I2C I2C_Transmit I2C_Error_t I2C_Transmit(I2C_ID_t i2c, uint16_t slaveAddr, uint8_t* pData, uint16_t length, uint32_t timeOut); Function Send data with I2C Parameters i2c：I2C ID slaveAddr:slave address pData:需要发送的数据 length：length timeOut:time out , unit: ms Return 是否成功发送数据 I2C_Receive I2C_Error_t I2C_Receive(I2C_ID_t i2c, uint16_t slaveAddr, uint8_t* pData, uint16_t length, uint32_t timeOut); Function 通过I2C接收数据 Parameters i2c：I2C ID slaveAddr:slave address pData:The location of the received data storage length：length timeOut:time out , unit: ms Return Whether or not to receive data successfully I2C_WriteMem I2C_Error_t I2C_WriteMem(I2C_ID_t i2c, uint16_t slaveAddr, uint32_t memAddr, uint8_t memSize, uint8_t* pData, uint16_t length, uint32_t timeOut); Function Write slave's register Parameters i2c：I2C ID slaveAddr:slave address memAddr：slave register address memSize：slave register address length,unit:byte, max 4 pData: data to write length：length of data to write timeOut:time out , unit: ms Return Whether the data is written successfully I2C_ReadMem I2C_Error_t I2C_ReadMem(I2C_ID_t i2c, uint16_t slaveAddr, uint32_t memAddr, uint8_t memSize, uint8_t* pData, uint16_t length, uint32_t timeOut); Function Read register of slave Parameters i2c：I2C ID slaveAddr:slave address memAddr：slave register address memSize： slave register address length,unit:byte, max 4 pData: data read length：length of read data read timeOut:time out , unit: ms Return Whether the data is read successfully I2C_WriteRawByte I2C_Error_t I2C_WriteRawByte(I2C_ID_t i2c, uint8_t sendByte, I2C_CMD_Mask_t cmdMask, uint32_t timeOut); Function Write byte raw Parameters i2c：I2C ID sendByte: data to send, one byte cmdMask：command value from I2C_CMD_Mask_t timeOut:time out , unit: ms Return Whether the data is written successfully I2C_ReadRawByte uint8_t I2C_ReadRawByte(I2C_ID_t i2c, I2C_CMD_Mask_t cmdMask, uint32_t timeOut); Function Read one byte raw Parameters i2c：I2C ID cmdMask： command value from I2C_CMD_Mask_t timeOut:time out , unit: ms Return the value read I2C_Close bool I2C_Close(I2C_ID_t i2c); Function Close I2C Parameters i2c：I2C ID Return Close success or not "},"c-sdk/function-api/spi.html":{"url":"c-sdk/function-api/spi.html","title":"SPI","keywords":"","body":"SPI A9/A9G has two SPI interfaces. When using it, pay attention to which pins are multiplexed and pin view the pin diagram of pudding development board. Open power first example:demo/spi Macro definition SPI_FREQ_MAX SPI maximum support frequency #define SPI_FREQ_MAX 13000000 Enumerated type SPI_ID_t SPI number, two SPI typedef enum { SPI1 = 1 , SPI2 = 2 , } SPI_ID_t; SPI_CS_t SPI CS pin, each SPI has two CS pins to choose from. typedef enum { SPI_CS_0 = 0 , SPI_CS_1 , SPI_CS_MAX } SPI_CS_t; SPI_Mode_t SPI mode is divided into four modes: polling, interruption, DMA polling and DMA interruption. typedef enum { /// Direct polling: The application sends/receives the data directly to/from /// the hardware module. The number of bytes actually sent/received is /// returned. SPI_MODE_DIRECT_POLLING , /// Direct IRQ: The application sends/receives the data directly to/from /// the hardware module. The number of bytes actually sent/received is /// returned. An Irq can be generated when the Tx/Rx FIFO reaches the /// pre-programmed level. SPI_MODE_DIRECT_IRQ , /// DMA polling: The application sends/receives the data through a DMA to /// the hardware module. The function returns 0 when no DMA channel is /// available. No bytes are sent. The function returns the number of bytes /// to send when a DMA resource is available. They will all be sent. A /// function allows to check if the previous DMA transfer is finished. No /// new DMA transfer in the same direction will be allowed before the end /// of the previous transfer. SPI_MODE_DMA_POLLING , /// DMA IRQ: The application sends/receives the data through a DMA to the /// hardware module. The function returns 0 when no DMA channel is /// available. No bytes are sent. The function returns the number of bytes /// to send when a DMA resource is available. They will all be sent. An /// IRQ is generated when the current transfer is finished. No new DMA /// transfer in the same direction will be allowed before the end of the /// previous transfer. SPI_MODE_DMA_IRQ , SPI_MODE_MAX } SPI_Mode_t; SPI_Line_t SPI supports 3 line and 4 line mode typedef enum{ SPI_LINE_3 = 3 , /// Half-Duplex Mode SPI_LINE_4 = 4 , /// Full-Duplex Mode } SPI_Line_t; SPI_Data_Bits_t SPI data bits typedef enum{ SPI_DATA_BITS_8 = 8 , SPI_DATA_BITS_16 = 16, } SPI_Data_Bits_t; Struct SPI_Irq_Flags_t SPI interrupt flag typedef struct { /// Rx FIFO overflow bool rxOverflow; /// Tx send finish bool txFinish; /// Tx DMA send finish bool txDmaDone; /// Rx send finish bool rxFinish; /// Rx DMA send finish bool rxDmaDone; } SPI_Irq_Flags_t; SPI_Config_t SPI configuration typedef struct { /// Select the Chip Select SPI_CS_t cs; /// Emission transfer mode SPI_Mode_t txMode; /// Reception transfer mode SPI_Mode_t rxMode; /// SPI clock frequency /// up to 13Mbits/s (SPI_FREQ_MAX) uint32_t freq; /// SPI transfer line mode SPI_Line_t line; /// SPI tx only /// false: tx only disable /// true: tx only enable bool txOnly; /// SPI Clk Polarity /// 0 when SPI is free,clk line is in low level /// 1 when SPI is free,clk line is in high level uint8_t cpol; /// SPI Clk Phase /// 0 SPI sampling data at the first edge /// 1 SPI sampling data at the second edge uint8_t cpha; /// SPI Cs Active Polarity /// true: Cs Active Low /// false: Cs Active High bool csActiveLow; /// SPI framesize SPI_Data_Bits_t dataBits; SPI_Irq_Handler_t irqHandler; SPI_Irq_Flags_t irqMask; } SPI_Config_t; Function SPI_Irq_Handler_t typedef void (*SPI_Irq_Handler_t)(SPI_Irq_Flags_t flags); Function SPI interrupt callback function Parameters flags: interrupt status flag Return None SPI_Init bool SPI_Init(SPI_ID_t spiN, SPI_Config_t spiConfig); Function Initialization of SPI Parameters spiN:SPI number spiConfig:SPI configuration Return whether or not it is successfully initialized SPI_Close bool SPI_Close(SPI_ID_t spiN); Function Shut down SPI Parameters spiN:SPI number Return whether SPI has been successfully closed SPI_Write uint32_t SPI_Write(SPI_ID_t spiN, const uint8_t *data, uint32_t length); Function Write data to SPI Parameters spiN:SPI number data: data to be sent length: the length of the data to be sent Return the length of the data sent successfully, if the return value in DMA mode is 0, it means that the DMA channel is not available. SPI_Read uint32_t SPI_Read(SPI_ID_t spiN, uint8_t *data, uint32_t length); Function Reading data from SPI Parameters spiN:SPI number data: the location of the stored data read length: the length of the data to be read Return read the length of the data, unit bytes SPI_IsTxDone bool SPI_IsTxDone(SPI_ID_t spiN); Function Check whether the last transmission has been completed. If the transmitted data is very important, this function is best invoked before closing the SPI. It should not be invoked in direct transmission and DMA transmission. Parameters spiN:SPI number Return If FIFO is sent empty, return to true; otherwise, return false. SPI_IsTxDmaDone bool SPI_IsTxDmaDone(SPI_ID_t spiN); Function If you want to know whether the SPI DMA is complete or not, when you send new data in DMA mode, you need to ensure that the previous data has been sent to completion. You can use this function to poll. It is important to note that the DMA transmission is completed but the sending FIFO may not be empty, so that the next DMA new data can be sent in time, and before the SPI is closed, it is necessary to check whether the SPI FIFO is empty with SPI_IsTxDone. Parameters spiN:SPI number Return DMA transmission is completed SPI_IsRxDmaDone bool SPI_IsRxDmaDone(SPI_ID_t spiN); Function Check whether the DMA received data is completed Parameters spiN:SPI number Return whether the data has been successfully received SPI_ClearTxDmaDone void SPI_ClearTxDmaDone(SPI_ID_t spiN); Function Clear the SPI DMA to send the completion flag Parameters spiN:SPI number Return None SPI_FlushFIFOs void SPI_FlushFIFOs(SPI_ID_t spiN); Function Refresh the buffer of two SPI (FIFO) Parameters spiN:SPI number Return None SPI_SetIrqHandler void SPI_SetIrqHandler(SPI_ID_t spiN, SPI_Irq_Handler_t handler); Function Setting the interrupt callback function Parameters spiN:SPI number handler: interrupt callback function Return None SPI_SetIrqMask void SPI_SetIrqMask(SPI_ID_t spiN, SPI_Irq_Flags_t irqMask); Function Set interrupt flag bits, even which interrupt flag bits can be. Parameters spiN:SPI number irqMask: interrupt sign Return None "},"c-sdk/function-api/timertc.html":{"url":"c-sdk/function-api/timertc.html","title":"time(RTC)","keywords":"","body":"time（RTC） Basic RTC time and system timestamp, as well as network practice synchronization. example:demo/time 时间相关类型 time_t Use integers to represent time typedef int32_t time_t; clock_t Use integers to represent time typedef long clock_t; Macro definition CLOCKS_PER_SEC System clock convert to second #define CLOCKS_PER_SEC (16384.0) CLOCKS_PER_MSEC System clock convert to microsecond #define CLOCKS_PER_MSEC (16.384) Struct tm Time representation, including days and days typedef struct tm{ int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }tm; timeval_t Time, seconds, and subtleties typedef struct timeval { time_t tv_sec; // seconds long tv_usec; //microsecond }timeval_t; timezone_t Time zone type typedef struct timezone { int tz_minuteswest; int tz_dsttime; }timezone_t; RTC_Time_t RTC time typedef struct{ uint16_t year; uint8_t month; uint8_t day; uint8_t hour; uint8_t minute; uint8_t second; int8_t timeZone; // timezone hour int8_t timeZoneMinutes; // timezone minutes that less than 1 hours // so `timezone = timeZone+timeZoneMinutes/60` }RTC_Time_t; Function gettimeofday int gettimeofday(timeval_t *tv, timezone_t *tz); Function Get system time, seconds, and microseconds Parameters TV: time information, seconds and microseconds TZ: unrealized, always NULL Return The success returns 0, otherwise not 0 TIME_SetIsAutoUpdateRtcTime void TIME_SetIsAutoUpdateRtcTime(bool isAutoUpdate); Function When you attach to the GPRS network, you will get the network time. If set to true, you will synchronize the network time to RTC local time. Set to false does not synchronize Parameters isAutoUpdate：Whether or not the network time is synchronized Return None TIME_IsAutoUpdateRtcTime bool TIME_IsAutoUpdateRtcTime(); Function Query whether the current configuration will automatically synchronize from the network to the local time. Parameters None Return Automatically synchronize network time to local, true: synchronization; false: asynchrony. TIME_SetRtcTime bool TIME_SetRtcTime(RTC_Time_t* time); Function Set local RTC time Parameters time: time Return Success or not TIME_GetRtcTIme bool TIME_GetRtcTIme(RTC_Time_t* time); Function Get local RTC time Parameters time:time Return Get time success or not clock clock_t clock(void); Function Get the system clock, note that not time, need to change, for example, converted to seconds need to be divided by 16384. Parameters None Return System clock "},"c-sdk/function-api/file-system.html":{"url":"c-sdk/function-api/file-system.html","title":"FS(Flash/TF Card)","keywords":"","body":"File System SDK does not currently provide flash related operations, but provides a more convenient and simple file system to use. You need to persist data or configuration information, just save it as a file. You can save data to flash internal or save it to the external TF card. example:demo/fs Macro definition FS_TFLASH_ROOT The location of the TF Card auto mount on system start #define FS_TFLASH_ROOT \"/t\" FS_O_RDONLY Read only #define FS_O_RDONLY 0 FS_O_WRONLY Write only #define FS_O_WRONLY 1 FS_O_RDWR Read and Write #define FS_O_RDWR 2 FS_O_ACCMODE When reading and writing file operations, get the low 2 bits flag (read the file permissions). #define FS_O_ACCMODE 3 FS_O_CREAT If a file exists, it will not affect, if it does not exist, it will be established and return to success. If a file exists and has FS_O_EXCL, it returns fail. #define FS_O_CREAT 00100 FS_O_EXCL If it is set at the same time as FS_O_CREAT, and the file already exists, then the creation of the file operation will fail and return -1. #define FS_O_EXCL 00200 FS_O_TRUNC If the file is present, it will be opened with only write or read only, and delete the contents before the file. #define FS_O_TRUNC 01000 FS_O_APPEND Append data #define FS_O_APPEND 02000 FS_ATTR_MARK File attribute flags #define FS_ATTR_MARK 0x0 FS_ATTR_RO File attribute read only #define FS_ATTR_RO 0x00000001 FS_ATTR_HIDDEN File attribute hidden #define FS_ATTR_HIDDEN 0x00000002 FS_ATTR_SYSTEM File attribute system file #define FS_ATTR_SYSTEM 0x00000004 FS_ATTR_VOLUME File attribute volume #define FS_ATTR_VOLUME 0x00000008 FS_ATTR_DIR File attribute folder #define FS_ATTR_DIR 0x00000010 FS_ATTR_ARCHIVE File attribute archive #define FS_ATTR_ARCHIVE 0x00000020 FS_SEEK_SET File position start #define FS_SEEK_SET 0 FS_SEEK_CUR file current position #define FS_SEEK_CUR 1 FS_SEEK_END file position end #define FS_SEEK_END 2 FS_DEVICE_NAME_T_FLASH TF card name #define FS_DEVICE_NAME_T_FLASH \"TF\" FS_DEVICE_NAME_FLASH Flash name #define FS_DEVICE_NAME_FLASH \"FLASH\" ERR_FS error code see:api_inc_fs.h #define ERR_FS_IS_DIRECTORY -4200001 #define ERR_FS_NOT_DIRECTORY -4200002 #define ERR_FS_NO_DIR_ENTRY -4200003 #define ERR_FS_OPERATION_NOT_GRANTED -4200005 #define ERR_FS_DIR_NOT_EMPTY -4200006 #define ERR_FS_FDS_MAX -4200007 #define ERR_FS_PROCESS_FILE_MAX -4200008 #define ERR_FS_FILE_EXIST -4200009 #define ERR_FS_NO_BASENAME -4200011 #define ERR_FS_BAD_FD -4200012 #define ERR_FS_NO_MORE_FILES -4200013 #define ERR_FS_HAS_MOUNTED -4200014 #define ERR_FS_MOUNTED_FS_MAX -4200015 #define ERR_FS_UNKNOWN_FILESYSTEM -4200016 #define ERR_FS_INVALID_DIR_ENTRY -4200018 #define ERR_FS_INVALID_PARAMETER -4200019 #define ERR_FS_NOT_SUPPORT -4200020 #define ERR_FS_UNMOUNT_FAILED -4200021 #define ERR_FS_NO_MORE_MEMORY -4200025 #define ERR_FS_DEVICE_NOT_REGISTER -4200027 #define ERR_FS_DISK_FULL -4200030 #define ERR_FS_NOT_FORMAT -4200032 #define ERR_FS_HAS_FORMATED -4200033 #define ERR_FS_NOT_FIND_SB -4200035 #define ERR_FS_DEVICE_BUSY -4200037 #define ERR_FS_OPEN_DEV_FAILED -4200038 #define ERR_FS_ROOT_FULL -4200039 #define ERR_FS_ACCESS_REG_FAILED -4200040 #define ERR_FS_PATHNAME_PARSE_FAILED -4200041 #define ERR_FS_READ_DIR_FAILED -4200048 #define ERR_FS_MOUNT_READ_ROOT_INODE_FAILED -4200050 #define ERR_FS_INVALID_DEV_NUMBER -4200051 #define ERR_FS_RENAME_DIFF_PATH -4200052 #define ERR_FS_FORMAT_MOUNTING_DEVICE -4200053 #define ERR_FS_DATA_DESTROY -4200056 #define ERR_FS_READ_SECTOR_FAILED -4200057 #define ERR_FS_WRITE_SECTOR_FAILED -4200058 #define ERR_FS_READ_FILE_EXCEED -4200059 #define ERR_FS_WRITE_FILE_EXCEED -4200060 #define ERR_FS_FILE_TOO_MORE -4200061 #define ERR_FS_FILE_NOT_EXIST -4200062 #define ERR_FS_DEVICE_DIFF -4200063 #define ERR_FS_GET_DEV_INFO_FAILED -4200064 #define ERR_FS_NO_MORE_SB_ITEM -4200065 #define ERR_FS_NOT_MOUNT -4200066 #define ERR_FS_NAME_BUFFER_TOO_SHORT -4200068 #define ERR_FS_NOT_REGULAR -42000100 #define ERR_FS_VOLLAB_IS_NULL -42000101 Struct API_FS_INFO File system size info typedef struct { UINT64 totalSize; // Total size UINT64 usedSize; // Has used size } API_FS_INFO; Function API_FS_Open int32_t API_FS_Open( PCSTR fileName, uint32_t operationFlag, uint32_t mode ); Function Open file Parameters fileName：File name, note that the name of the file is only encoded by Unicode, First call LocalLanguage2UnicodeBigEndian to convert the character format to unicode encoding. operationFlag：Operation marks, such as read-only, write only, and so on (`FSO...), can be carried out or calculated by multiple operations. mode：Mode, file or folder attribute, `FSATTR..., can be performed or calculated by multiple operations. Return if success, return file descriptor id(>=0),or return error code API_FS_Close int32_t API_FS_Close( int32_t fd ); Function Close file Parameters fd：The file descriptor, the return value of the API_FS_Open Return return 0 if success, or return error code API_FS_Read int32_t API_FS_Read( int32_t fd, uint8_t* pBuffer, uint32_t length ); Function read data Parameters fd：The file descriptor, the return value of the API_FS_Open pBuffer:The location of the read data storage length: Length of read data Return data length of read success, or error code API_FS_Write int32_t API_FS_Write( int32_t fd, uint8_t* pBuffer, uint32_t length ); Function Write file Parameters fd：The file descriptor, the return value of the API_FS_Open pBuffer: Data to write length: Data length Return Write length, or return error code API_FS_Flush uint32_t API_FS_Flush( int32_t fd ); Function Flush cache Parameters fd：The file descriptor, the return value of the API_FS_Open Return 0 or error code API_FS_Create int32_t API_FS_Create( PCSTR fileName, uint32_t mode ); Function Create file Parameters fileName:file anme with unicode encoding mode：file attribute FS_ATTR_... Return return 0 or error code API_FS_Delete int32_t API_FS_Delete( PCSTR fileName ); Function Delete file Parameters fileName:file name with unicode encoding Return success reutrn 0 or return error code API_FS_Seek int64_t API_FS_Seek( int32_t fd, int64_t offset, uint8_t origin ); Function Set file pointer position Parameters fd：The file descriptor, the return value of the API_FS_Open offset：Offset, the number of offset bytes relative to origin origin：The starting address, the specific location or the special value of the offset: `FSSEEK... Return 0 or error code API_FS_IsEndOfFile int32_t API_FS_IsEndOfFile( int32_t fd ); Function Determine whether the file pointer is at the end of the file Parameters fd：The file descriptor, the return value of the API_FS_Open Return return 1 if is the end of file , return 0 if not, or error code API_FS_Rename int32_t API_FS_Rename( PCSTR oldName, PCSTR newName ); Function Rename file name Parameters oldName: old name with unicode encoding newName: new name with unicode encoding Return return 0 or error code API_FS_GetFileName int32_t API_FS_GetFileName( int32_t fd, int32_t nameBufferLen, uint8_t* fileName ); Function Obtaining the file name based on the file descriptor Parameters fd：The file descriptor, the return value of the API_FS_Open nameBufferLen：buffer length fileName：the name read Return return 0 if success, or return error code API_FS_GetFileSize int64_t API_FS_GetFileSize( int32_t fd ); Function Get file size Parameters fd：The file descriptor, the return value of the API_FS_Open Return file size or error code API_FS_GetDirSize int64_t API_FS_GetDirSize( PCSTR fileName, uint64_t* size ); Function Get folder size Parameters fileName：file name with unicode encoding size：folder size Return return 0 if success, or return error code API_FS_GetCurDir int32_t API_FS_GetCurDir( uint32_t size, PSTR pCurDir ); Function Get current folder name Parameters size：size of name buffer pCurDir：name buffer Return return 0 if success, or return error code API_FS_ChangeDir int32_t API_FS_ChangeDir( PCSTR pDirName ); Function Change current directory Parameters pDirName：folder name with unicode encofing Return return 0 if success, or return error code API_FS_Mkdir int32_t API_FS_Mkdir( PCSTR fileName, uint32_t mode ); Function Creat folder Parameters fileName：file name with unicode encoding mode：folder attribute FS_ATTR_... Return return 0 if success, or return error code API_FS_Rmdir int32_t API_FS_Rmdir( PCSTR dirName ); Function Delete folder Parameters dirName：folder name with unicode encofing Return return 0 if success, or return error code API_FS_GetFSInfo int32_t API_FS_GetFSInfo( PCSTR pDevName, API_FS_INFO* pFsInfo ); Function Get file system size infomation Parameters pDevName: device name FS_DEVICE_NAME_... pFsInfo: size infomation Return return 0 if success, or return error code "},"c-sdk/function-api/gprs-network.html":{"url":"c-sdk/function-api/gprs-network.html","title":"GPRS Network","keywords":"","body":"GPRS related and base station information After the module is powered up, it will automatically register the GSM network. After successful registration, you can call and send SMS. To achieve the Internet function, we need to activate the GPRS network. The basic knowledge of GPRS has been explained in the basic knowledge part of this article. We know that activating the GPRS network requires two steps: attachment and context activation. Moreover, these two steps have priority in order to first attach and then activate context. Network related events and parameters can be find in api_event.h examples:demo/network Macro definition PDP_APN_MAX_LENGTH APN max length #define PDP_APN_MAX_LENGTH 64 PDP_USER_NAME_MAX_LENGTH PDP username max length #define PDP_USER_NAME_MAX_LENGTH 64 PDP_USER_PASSWD_MAX_LENGTH PDP user password #define PDP_USER_PASSWD_MAX_LENGTH 64 Struct Network_Status_t Network status typedef enum{ NETWORK_STATUS_OFFLINE = 0 , NETWORK_STATUS_REGISTERING , NETWORK_STATUS_REGISTERED , NETWORK_STATUS_DETACHED , NETWORK_STATUS_ATTACHING , NETWORK_STATUS_ATTACHED , NETWORK_STATUS_DEACTIVED , NETWORK_STATUS_ACTIVATING , NETWORK_STATUS_ACTIVATED , NETWORK_STATUS_ATTACH_FAILED , NETWORK_STATUS_ACTIVATE_FAILED , NETWORK_STATUS_MAX }Network_Status_t; Network_PDP_Context_t PDP context parameters typedef struct{ char apn[PDP_APN_MAX_LENGTH]; // Access Point Name char userName[PDP_USER_NAME_MAX_LENGTH]; char userPasswd[PDP_USER_PASSWD_MAX_LENGTH]; }Network_PDP_Context_t; Network_Location_t Base stattion information typedef struct { uint8_t sMcc[3]; //移动国家号码，中国为460 uint8_t sMnc[3]; //移动网号，中国移动00，中国联通01 uint16_t sLac; //位置区号码 uint16_t sCellID; //小区识别码 uint8_t iBsic; //基站识别码 int8_t iRxLev; //接收报告信号强度 uint8_t iRxLevSub; //接收报告信号强度小数部分 uint16_t nArfcn; //基站频点 } Network_Location_t; Network_Error_t Network error information typedef enum{ NETWORK_ERROR_NONE = 0 , NETWORK_ERROR_MAX } Network_Error_t; Function Network_Callback_Func_t typedef void (*Network_Callback_Func_t)(Network_Status_t status); Function Network callback, defined by user Parameters status：Network status Return None Network_SetStatusChangedCallback void Network_SetStatusChangedCallback(Network_Callback_Func_t callback); Function Setting up the callback function of the network, besides using the callback function, can also receive events from the bottom of the main task(recommend). Parameters callback: Network status callback function Return None Network_StartAttach bool Network_StartAttach(); Function Start attach network Parameters None Return true: successful execution of attached network. After successful attachment, events will occur. False: failure of attachment may be attached or unable to be attached. Network_StartDetach bool Network_StartDetach(); Function Detach network Parameters None Return true：success，false：fail Network_StartActive bool Network_StartActive(Network_PDP_Context_t context); Function Start context activation Parameters context：PDP context settings Return If activation is successful, if it fails, check the signal and whether the network has been attached. Network_StartDeactive bool Network_StartDeactive(uint8_t contextID); Function Deactive context Parameters contextID：Context ID, reserved, fixed to 1 Return return true execute success, or false, Whether activation is successful or not will produce an event. Network_GetIp bool Network_GetIp(char* ip, uint8_t size); Function Get GPRS ip address, Note that the IP address here is not the public network address, but the LAN address. Parameters ip：ip address size：ip string length Return Is succeed to get ip Network_GetCellInfoRequst bool Network_GetCellInfoRequst(); Function Get base station information request, cell information will report by event API_EVENT_ID_NETWORK_CELL_INFO Parameters None Return Is get base station information success "},"c-sdk/function-api/dns.html":{"url":"c-sdk/function-api/dns.html","title":"DNS","keywords":"","body":"DNS Get ip from domain name example：demo/dns Enumerated type DNS_Status_t DNS status typedef enum{ DNS_STATUS_ERROR = -1, DNS_STATUS_OK = 0, DNS_STATUS_WAIT = 1, DNS_STATUS_MAX }DNS_Status_t; Function DNS_CALLBACK_FUNC_T typedef VOID (*DNS_CALLBACK_FUNC_T)(DNS_Status_t status, void* param); Function DNS callback funtion Parameters status:DNS status param：parameter Return None DNS_GetHostByName DNS_Status_t DNS_GetHostByName(const char* domain, char* ip); Function Resolve domain names to IP addresses, because domain name resolution sometimes takes a long time. In order not to block programs, the return value may be DNS_STATUS_WAIT, that is, domain name resolution has not yet been completed, and events will happen after completion. Parameters domain： domain name ip：ip address output, ensure array have enough length, e.g:127.0.0.1 Return DNS_STATUS_OK：success, DNS_STATUS_ERROR: error, DNS_STATUS_WAIT：wait for resolve DNS_GetHostByNameEX DNS_Status_t DNS_GetHostByNameEX(const char *hostname, char* ip, DNS_CALLBACK_FUNC_T func, void* param); Function Resolve the domain name to the IP address, and call the callback function after success. Parameters hostname：domain name ip：ip address output, ensure array have enough length, e.g:127.0.0.1 fuc: callback function param:the parameter to callback function Return DNS_STATUS_OK: success, DNS_STATUS_ERROR: error, DNS_STATUS_WAIT:wait for result DNS_GetHostByName2 int32_t DNS_GetHostByName2(const char* domain, char* ip); Function Parsing domain name to IP address with block way, easy to use, but poor performance. Parameters hostname：domain name ip：ip address output, ensure array have enough length, e.g:127.0.0.1 Return 0: success, other:error code "},"c-sdk/function-api/socket.html":{"url":"c-sdk/function-api/socket.html","title":"Socket","keywords":"","body":"Socket Socket service requires GPRS network to be used normally. example:demo/socket Enumerated type TCP_UDP_t TCP、UDP typedef enum{ TCP = 0, UDP =1 }TCP_UDP_t; API_Socket_Error_t Error code typedef enum{ /** No error, everything OK. */ API_SOCKET_ERROR_NONE = 0, /** Out of memory error. */ API_SOCKET_ERROR_MEM = -1, /** Buffer error. */ API_SOCKET_ERROR_BUF = -2, /** Timeout. */ API_SOCKET_ERROR_TIMEOUT = -3, /** Routing problem. */ API_SOCKET_ERROR_RTE = -4, /** Operation in progress */ API_SOCKET_ERROR_INPROGRESS = -5, /** Illegal value. */ API_SOCKET_ERROR_VAL = -6, /** Operation would block. */ API_SOCKET_ERROR_WOULDBLOCK = -7, /** Address in use. */ API_SOCKET_ERROR_USE = -8, /** Already connecting. */ API_SOCKET_ERROR_ALREADY = -9, /** Conn already established.*/ API_SOCKET_ERROR_ISCONN = -10, /** Not connected. */ API_SOCKET_ERROR_CONN = -11, /** Low-level netif error */ API_SOCKET_ERROR_IF = -12, /** Connection aborted. */ API_SOCKET_ERROR_ABRT = -13, /** Connection reset. */ API_SOCKET_ERROR_RST = -14, /** Connection closed. */ API_SOCKET_ERROR_CLSD = -15, /** Illegal argument. */ API_SOCKET_ERROR_ARG = -16 }API_Socket_Error_t; Function Socket_TcpipConnect int Socket_TcpipConnect(TCP_UDP_t tcpOrUdp, const char* ip,uint16_t port); Function Connect server Parameters tcpOrUdp: selects the TCP protocol or UDP IP: the IP address to be connected port: the server port to be connected Return If successful, return the file descriptor FD. If it fails, return the error message API_Socket_Error_t Socket_TcpipWrite int Socket_TcpipWrite(int socketFd, uint8_t* data, uint16_t length); Function Sending data to the server Parameters the socket connection file descriptor established by socketFd:, and the return value after successful Socket_TcpipConnect. data: data to be sent length: the length of the data to be sent Return the data length or error code that is successfully sent Socket_TcpipRead int Socket_TcpipRead( int socketFd, uint8_t* data, uint16_t length); Function After the connection is established, information received from the server will generate events. After the event is triggered, the read function can be called to read the data. Parameters the socket connection file descriptor established by socketFd:, and the return value after successful Socket_TcpipConnect. data: the location of the received data storage length: the length of the data to be sent Return the length of the data read or the error code Socket_TcpipClose bool Socket_TcpipClose(int socketFd); Function Close socket connection Parameters socketFd:The socket connection file descriptor established, the return value after successful Socket_TcpipConnect. Return Whether or not the socket connection is successfully closed "},"c-sdk/function-api/ssl-tls.html":{"url":"c-sdk/function-api/ssl-tls.html","title":"SSL/TLS","keywords":"","body":"SSL/TLS If you are not familiar with SSL/TLS and feel that all kinds of certificates are very confusing, you can refer to this article to generate certificate example:demo/ssl Enumerated type SSL_Version_t SSL/TLS version typedef enum{ SSL_VERSION_SSLv3 = 0, SSL_VERSION_TLSv1 , SSL_VERSION_TLSv1_1 , SSL_VERSION_TLSv1_2 , SSL_VERSION_MAX }SSL_Version_t; SSL_Error_t error message typedef enum{ SSL_ERROR_NONE = 0x00 , SSL_ERROR_PARAM = -0x01 , SSL_ERROR_PARSE = -0x02 , SSL_ERROR_MALLOC_FAIL= -3 , SSL_ERROR_CONNECTION = -4 , SSL_ERROR_TIMEOUT = -5 , SSL_ERROR_FAIL = -6 , SSL_ERROR_INTERNAL , SSL_ERROR_MAX } SSL_Error_t; SSL_Verify_Mode_t Validation mode typedef enum{ SSL_VERIFY_MODE_NONE = 0, SSL_VERIFY_MODE_OPTIONAL = 1, SSL_VERIFY_MODE_REQUIRED = 2, SSL_VERIFY_MODE_MAX }SSL_Verify_Mode_t; Struct SSL_Config_t SSL/TLS configuration typedef struct{ const char* caCert; const char* caCrl; const char* clientCert; const char* clientKey; const char* clientKeyPasswd; const char* hostName; SSL_Version_t minVersion; SSL_Version_t maxVersion; SSL_Verify_Mode_t verifyMode; const char* entropyCustom; //自定义混淆字符 ////////////////////////////////// void* obj;//do not edit it ////////////////////////////////// } SSL_Config_t; Function SSL_Init SSL_Error_t SSL_Init(SSL_Config_t* sslConfig); Function Init SSL/TLS Parameters sslConfig:Initialization configuration parameters Return Return error information SSL_Connect SSL_Error_t SSL_Connect(SSL_Config_t* sslConfig, const char* server, const char* port); Function Connect the server with the SSL/TLS protocol Parameters sslConfig:SSL/TLS configuration information server: SSL/TLS server that needs to be connected port: server port Return Return error information SSL_Write int SSL_Write(SSL_Config_t* sslConfig, uint8_t* data, int length, int timeoutMs); Function SSL/TLS Sending data (blocking) Parameters sslConfig:SSL/TLS configuration data: data sent to the server the length of the data sent to the server by length: timeoutMs: sends timeout time (reserved, temporarily unavailable) Return Data length or error code that is successfully sent SSL_Read int SSL_Read(SSL_Config_t* sslConfig, uint8_t* data, int length, int timeoutMs); Function Read the data Parameters sslConfig:SSL/TLS configuration data: received data the length of the data received by length: timeoutMs: receives timeout time Return The data length or error code that is successfully received SSL_Close SSL_Error_t SSL_Close(SSL_Config_t* sslConfig); Function Close connection Parameters sslConfig:SSL/TLS configuration Return error message SSL_Destroy SSL_Error_t SSL_Destroy(SSL_Config_t* sslConfig); Function Release the space occupied by SSL/TLS Parameters sslConfig:SSL/TLS configuration Return error code of release "},"c-sdk/function-api/mqtt.html":{"url":"c-sdk/function-api/mqtt.html","title":"MQTT","keywords":"","body":"MQTT MQTT is a protocol based on subscription publishing model. It is widely used in real time chat (IM) and Internet of things. example: demo/mqtt demo/mqtt_ssl Pay Attention: The Function related to MQTT only can be called in thread(task), can't call in interrup callback function, or errors occurs, refer to the demo code. Enumerated type MQTT_Error_t MQTT error code typedef enum{ MQTT_ERROR_NONE = 0, //no error /** Out of memory error. */ MQTT_ERROR_MEM = -1, /** Buffer error. */ MQTT_ERROR_BUF = -2, /** Timeout. */ MQTT_ERROR_TIMEOUT = -3, /** Routing problem. */ MQTT_ERROR_RTE = -4, /** Operation in progress */ MQTT_ERROR_INPROGRESS = -5, /** Illegal value. */ MQTT_ERROR_VAL = -6, /** Operation would block. */ MQTT_ERROR_WOULDBLOCK = -7, /** Address in use. */ MQTT_ERROR_USE = -8, /** Already connecting. */ MQTT_ERROR_ALREADY = -9, /** Conn already established.*/ MQTT_ERROR_ISCONN = -10, /** Not connected. */ MQTT_ERROR_CONN = -11, /** Low-level netif error */ MQTT_ERROR_IF = -12, /** Connection aborted. */ MQTT_ERROR_ABRT = -13, /** Connection reset. */ MQTT_ERROR_RST = -14, /** Connection closed. */ MQTT_ERROR_CLSD = -15, /** Illegal argument. */ MQTT_ERROR_ARG = -16, MQTT_ERROR_PARAM = -17, MQTT_ERROR_DNS = -18 }MQTT_Error_t; MQTT_SSL_Version_t MQTT SSL version typedef enum{ MQTT_SSL_VERSION_SSLv3 = 0, MQTT_SSL_VERSION_TLSv1 , MQTT_SSL_VERSION_TLSv1_1 , MQTT_SSL_VERSION_TLSv1_2 , MQTT_SSL_VERSION_MAX }MQTT_SSL_Version_t; MQTT_SSL_Verify_Mode_t Verify mode typedef enum{ MQTT_SSL_VERIFY_MODE_NONE = 0, MQTT_SSL_VERIFY_MODE_OPTIONAL = 1, MQTT_SSL_VERIFY_MODE_REQUIRED = 2, MQTT_SSL_VERIFY_MODE_MAX }MQTT_SSL_Verify_Mode_t; MQTT_Connection_Status_t MQTT connection status typedef enum { /** Accepted */ MQTT_CONNECTION_ACCEPTED = 0, /** Refused protocol version */ MQTT_CONNECTION_REFUSED_PROTOCOL_VERSION = 1, /** Refused identifier */ MQTT_CONNECTION_REFUSED_IDENTIFIER = 2, /** Refused server */ MQTT_CONNECTION_REFUSED_SERVER = 3, /** Refused user credentials */ MQTT_CONNECTION_REFUSED_USERNAME_PASS = 4, /** Refused not authorized */ MQTT_CONNECTION_REFUSED_NOT_AUTHORIZED = 5, /** Disconnected */ MQTT_CONNECTION_DISCONNECTED = 256, /** Timeout */ MQTT_CONNECTION_TIMEOUT = 257, MQTT_CONNECTION_DNS_FAIL = 258, MQTT_CONNECTION_STATUS_MAX }MQTT_Connection_Status_t; MQTT_Flags_t MQTT flags typedef enum{ MQTT_FLAG_NONE = 0 , MQTT_FLAG_DATA_LAST = 1 , MQTT_FLAG_MAX }MQTT_Flags_t; Struct MQTT_Client_t MQTT object typedef struct{ void* mqttClient; }MQTT_Client_t; MQTT_Connect_Info_t MQTT connection configuration typedef struct{ /** Client identifier, must be set by caller */ const char *client_id; /** User name, set to NULL if not used */ const char* client_user; /** Password, set to NULL if not used */ const char* client_pass; /** keep alive time in seconds, 0 to disable keep alive functionality*/ uint16_t keep_alive; /** will topic, set to NULL if will is not to be used, will_msg, will_qos and will retain are then ignored */ const char* will_topic; /** will_msg, see will_topic */ const char* will_msg; /** will_qos, see will_topic */ uint8_t will_qos; /** will_retain, see will_topic */ uint8_t will_retain; uint8_t clean_session; /** SSL/TLS configuration for secure connections */ bool use_ssl; MQTT_SSL_Verify_Mode_t ssl_verify_mode; const char* ca_cert; const char* ca_crl; const char* client_cert; const char* client_key; const char* client_key_passwd; const char* broker_hostname; MQTT_SSL_Version_t ssl_min_version; MQTT_SSL_Version_t ssl_max_version; const char* entropy_custom; //自定义混淆字符 }MQTT_Connect_Info_t; Function MQTT_Connection_Callback_t typedef void (*MQTT_Connection_Callback_t)(MQTT_Client_t* client, void* arg, MQTT_Connection_Status_t status); Function Connection callback Parameters client：MQTT client object arg：parameter from connect function status:MQTT Return None MQTT_Request_Callback_t typedef void (*MQTT_Request_Callback_t)(void* arg, MQTT_Error_t err); Function MQTT request callback Parameters arg：param from request function err：error code Return None MQTT_InPub_Callback_t typedef void (*MQTT_InPub_Callback_t)(void* arg, const char* topic, uint32_t payloadLen); Function MQTT data header callback when received publish request Parameters arg：the param from callback function setting function topic：topic of message payloadLen：payload length of message Return None MQTT_InPub_Data_Callback_t typedef void (*MQTT_InPub_Data_Callback_t)(void* arg, const uint8_t* data, uint16_t len, MQTT_Flags_t flags); Function MQTT message body, receive before MQTT_InPub_Callback_t Parameters arg：the param from callback function setting function data：payload data len：payload data length flags：flag, MQTT_FLAG_DATA_LAST means this message is the last slice data Return None MQTT_ClientNew MQTT_Client_t* MQTT_ClientNew(); Function Create a MQTT client object Parameters None Return MQTT client object MQTT_Connect MQTT_Error_t MQTT_Connect(MQTT_Client_t* client, const char* domainOrIp,uint16_t port, MQTT_Connection_Callback_t callback, void* arg, const MQTT_Connect_Info_t* connectInfo); Function Connect the MQTT server(broker) Parameters client:MQTT client object domainOrIp: server address port: server port callback: connect the successful callback function Arg: parameters that need to be passed to the successful callback function connectInfo: connection configuration Return MQTT Conenction error MQTT_Disconnect MQTT_Error_t MQTT_Disconnect(MQTT_Client_t* client); Function Disconnect the connection to the MQTT server (broker) Parameters client：MQTT client object Return MQTT connection error MQTT_SetInPubCallback void MQTT_SetInPubCallback(MQTT_Client_t* client, MQTT_InPub_Callback_t inpubCallback, MQTT_InPub_Data_Callback_t dataInpubCallback, void* arg); Function Setting the callback function when MQTT receives the subscription message Parameters client:MQTT client object inpubCallback: callback function when the subscription message is received. dataInpubCallback: message volume callback function when the subscription message is received. Arg: parameters that need to be passed to the successful callback function Return None MQTT_Subscribe MQTT_Error_t MQTT_Subscribe(MQTT_Client_t* client, const char* topic, uint8_t qos, MQTT_Request_Callback_t callback, void* arg); Function Subscribe to a subscription subject request to the MQTT server (broker) Parameters client:MQTT client object topic: topic QoS: quality of service callback: subscribe to the topic callback function Arg: parameters that need to be passed to the callback function Return MQTT connection error information MQTT_Unsubscribe MQTT_Error_t MQTT_Unsubscribe(MQTT_Client_t* client, const char* topic, MQTT_Request_Callback_t callback, void* arg); Function Cancel the subscription topic from the MQTT server (broker) Parameters client:MQTT client object topic: topic callback: subscribe to the topic callback function Arg: parameters that need to be passed to the callback function Return MQTT connection error information MQTT_Publish MQTT_Error_t MQTT_Publish(MQTT_Client_t* client, const char* topic, const void* payload, uint16_t payloadLen, uint8_t dup, uint8_t qos, uint8_t retain, MQTT_Request_Callback_t callback, void* arg); Function Publish messages to the MQTT server (broker) Parameters client:MQTT client object topic: topic port: server port payload: message body payloadLen: message body length DUP: indicating the number of sending repeats QoS: quality of service retain: needs the server to keep the message persisted callback: publish request callback function Arg: parameters that need to be passed to the callback function Return MQTT connection error information MQTT_IsConnected uint8_t MQTT_IsConnected(MQTT_Client_t* client); Function Whether the query has been connected to the MQTT server (broker) Parameters client：MQTT client object Return return 0 If not connected, or return other value "},"c-sdk/function-api/power-manager.html":{"url":"c-sdk/function-api/power-manager.html","title":"Power Manager","keywords":"","body":"Power Manager It contains some basic power related operations, peripheral power settings, shutdown, restart, low power consumption, etc. Release of power button will cause an event: API_EVENT_ID_KEY_DOWN, API_EVENT_ID_KEY_UP example:demo/pm Enumerated type Power_Type_t Peripherals power supply typedef enum{ POWER_TYPE_VPAD = 0, // GPIO0 ~ GPIO7 and GPIO25 ~ GPIO36 2.8V //always on POWER_TYPE_MMC, // GPIO8 ~ GPIO13 1.9V POWER_TYPE_LCD, // GPIO14 ~ GPIO18 1.9V POWER_TYPE_CAM, // GPIO19 ~ GPIO24 1.9V POWER_TYPE_MAX }Power_Type_t; Power_On_Cause_t Cause of opening typedef enum{ POWER_ON_CAUSE_KEY = 0 , POWER_ON_CAUSE_CHARGE , POWER_ON_CAUSE_ALARM , POWER_ON_CAUSE_EXCEPTION, POWER_ON_CAUSE_RESET , POWER_ON_CAUSE_MAX }Power_On_Cause_t; Function PM_PowerEnable bool PM_PowerEnable(Power_Type_t powerType, bool isOn); Function It is important to enable peripheral power. When you use peripherals, you must turn on the power supply before you can use it. Parameters powerType: peripherals power supply isOn: switch Return Whether or not it has been successfully set up PM_SleepMode void PM_SleepMode(bool isSleepMode); Function Low power mode, low power mode will reduce the main frequency to 32kHz, the program will still run, and can be called back to restore this function. At the same time, it can turn off peripherals and their power to reduce power consumption. Parameters isSleepMode：Whether or not to enter a low power mode, true enters Return None PM_Voltage uint16_t PM_Voltage(uint8_t* percent); Function Check the battery voltage Parameters percent:Percentage of battery power Return Voltage value, unit: milli V PM_ShutDown void PM_ShutDown(); Function Turn off the machine Parameters None Return None PM_Restart void PM_Restart(); Function Reboot system Parameters None Return None "},"c-sdk/function-api/call.html":{"url":"c-sdk/function-api/call.html","title":"Call","keywords":"","body":"CALL Call communication and DTMF support example：demo/call Enumerated type CALL_DTMF_Gain_t DTMF gain typedef enum { CALL_DTMF_GAIN_0dB = 0, CALL_DTMF_GAIN_m3dB, CALL_DTMF_GAIN_m9dB, CALL_DTMF_GAIN_m15dB, CALL_DTMF_GAIN_MAX } CALL_DTMF_Gain_t; Power_On_Cause_t error info typedef enum{ CALL_ERROR_NONE = 0 , CALL_ERROR_NO_DIAL_TONE , //TERMINAL USER HAS POWERED OFF CALL_ERROR_BUSY , //TERMINAL USER RETURN UDUB CALL_ERROR_NO_ANSWER , //TERMINAL USER DOESN'T ANSWER THE CALL CALL_ERROR_NO_CARRIER , //remote hang up CALL_ERROR_NETWORK_TIME_OUT , CALL_ERROR_LINK_IS_BEINDG_BUILT , //link is being built, can not hang up CALL_ERROR_UNKOWN , CALL_ERROR_MAX }CALL_Error_t; Function CALL_Dial bool CALL_Dial(const char* number); Function make a phone call Parameters number：the number to make a call Return make call succeed or not CALL_HangUp bool CALL_HangUp(); Function Hang up call Parameters None Return Hang up call succeed or not CALL_Answer bool CALL_Answer(); Function Answer a phone call Parameters None Return succeed answer a call or not CALL_DTMF bool CALL_DTMF(char dtmf, CALL_DTMF_Gain_t attenuation, uint8_t duration, uint8_t speakerGain, bool send); Function Make a DTMF tone, if received a DTMF tone , event API_EVENT_ID_CALL_DTMF will be be generated, parameters refer to api_event.h Parameters dtmf:DTMF tone value： '0'~'9', '#', '*', 'A'~'D' attenuation：attenuation speakerGain：speaker gain send: send DTMF tone and play in speaker if set to true, or just play in speaker and not send Return Succeed to make a DTMF tone or not CALL_Status bool CALL_Status(CALL_Status_t** callStatus, uint8_t* count); Function query call infomation while make a call or received call, you must call OS_Free() to free memory later e.g. CALL_Status_t* callStatus = NULL; uint8_t count; bool ret = CALL_Status(&callStatus,count); uint8_t i; if(ret) { for(i=0;i Parameters callStatus: The pointer to the call infomation, and value is NULL count: call infomation count Return return true if got call infomation, or false "},"c-sdk/function-api/sms.html":{"url":"c-sdk/function-api/sms.html","title":"SMS","keywords":"","body":"SMS Short message function example:demo/sms Macro definition SMS_PHONE_NUMBER_MAX_LEN The longest length of the telephone number #define SMS_PHONE_NUMBER_MAX_LEN 21 SMS_BODY_MAX_LEN The longest length of message message body (bytes) #define SMS_BODY_MAX_LEN 176 Enumerated type SMS_Format_t SMS format, currently only supporting text format typedef enum{ // SMS_FORMAT_PDU = 0, // not support now SMS_FORMAT_TEXT = 1, // default SMS_FORMAT_MAX } SMS_Format_t; SMS_Error_t error message typedef enum{ SMS_ERROR_DECODE_ERROR = 0, SMS_ERROR_MAX } SMS_Error_t; SMS_Encode_Type_t Encoding format, including ASCII and Unicode typedef enum{ SMS_ENCODE_TYPE_ASCII = 0, SMS_ENCODE_TYPE_UNICODE , SMS_ENCODE_TYPE_MAX } SMS_Encode_Type_t; SMS_Number_Type_t Number area type typedef enum{ SMS_NUMBER_TYPE_UNKNOWN = 129 , SMS_NUMBER_TYPE_INTERNATIONAL = 145 , SMS_NUMBER_TYPE_NATIONAL = 161 } SMS_Number_Type_t; //SMS_Server_Center_Addr_Type_t; SMS_Status_t SMS status typedef enum{ SMS_STATUS_UNREAD = 0x01 , SMS_STATUS_READ = 0x02 , SMS_STATUS_UNSENT = 0x04 , SMS_STATUS_SENT_NOT_SR_REQ = 0x08 , SMS_STATUS_SENT_SR_REQ_NOT_RECV = 0x10 , SMS_STATUS_SENT_SR_REQ_NOT_STORE = 0x20 , SMS_STATUS_SENT_SR_REQ_RECV_STORE = 0x40 , SMS_STATUS_ALL = 0x80 , SMS_STATUS_MAX } SMS_Status_t; SMS_Storage_t SMS storage location typedef enum{ SMS_STORAGE_FLASH = 1, SMS_STORAGE_SIM_CARD = 2, SMS_STORAGE_MAX } SMS_Storage_t; Struct SMS_Parameter_t Short message parameter typedef struct { uint8_t fo; // default: 17 uint8_t vp; // default: 167 uint8_t pid; // default: 0 uint8_t dcs; // default: 0:English 7bit, 4:English 8 bit, 8:Unicode 2 Bytes(UCS2) } SMS_Parameter_t; SMS_Server_Center_Info_t SMS center information typedef struct{ char* addr; SMS_Number_Type_t addrType; } SMS_Server_Center_Info_t; SMS_Message_Info_t Short message typedef struct{ //header uint8_t index; SMS_Status_t status; SMS_Number_Type_t phoneNumberType; char phoneNumber[SMS_PHONE_NUMBER_MAX_LEN]; RTC_Time_t time; //body uint16_t dataLen; uint8_t* data; } SMS_Message_Info_t; SMS_Storage_Info_t Short message storage information typedef struct{ uint16_t used; uint16_t total; uint16_t unReadRecords; uint16_t readRecords; uint16_t sentRecords; uint16_t unsentRecords; uint16_t unknownRecords; uint16_t storageId; } SMS_Storage_Info_t; Function SMS_SetFormat bool SMS_SetFormat(SMS_Format_t format, SIM_ID_t simID); Function Setting short message format Parameters format: format, currently only support character format simID: card ID, only SIM0 Return whether or not it is successful SMS_SetParameter bool SMS_SetParameter(SMS_Parameter_t* smsParameter,SIM_ID_t simID); Function Setting short message parameters Parameters smsParameter: short message parameters simID: card ID, only SIM0 Return whether or not it is successful SMS_SendMessage bool SMS_SendMessage(const char* phoneNumber, const uint8_t* message, uint8_t length, SIM_ID_t simID); Function Send text messages Parameters phoneNumber: telephone number message: note content, attention must be Unicode encoding, SMS_LocalLanguage2Unicode conversion can be used. length: short message length (bytes) simID: is fixed to SIM0 Return whether or not it is successfully sent SMS_SetServerCenterInfo bool SMS_SetServerCenterInfo(SMS_Server_Center_Info_t* serverCenterInfo); Function Setting up SMS center information Parameters serverCenterInfo：SMS center information Return whether SMS center information is successfully set up SMS_GetServerCenterInfo bool SMS_GetServerCenterInfo(SMS_Server_Center_Info_t* serverCenterInfo); Function Getting SMS center information Parameters serverCenterInfo：SMS center information Return whether or not a message center information is successfully obtained SMS_ListMessageRequst bool SMS_ListMessageRequst(SMS_Status_t smsStatus,SMS_Storage_t storage); Function Request to list saved SMS, SMS message will produce API_EVENT_ID_SMS_LIST_MESSAGE by event. See api_event.h Parameters smsStatus：Choose which types of SMS to list, such as listing only unread messages SMS_STATUS_UNREAD Return whether or not a message is successfully requested to read short messages SMS_DeleteMessage bool SMS_DeleteMessage(uint8_t index,SMS_Status_t status,SMS_Storage_t storage); Function Delete saved SMS Parameters index: the subscript of the saved SMS storage: select the storage location, flash or SIM card Return whether or not to delete messages successfully SMS_GetStorageInfo bool SMS_GetStorageInfo(SMS_Storage_Info_t* storageInfo, SMS_Storage_t storage); Function Get message storage information Parameters storageInfo: storage information storage: select the location of the storage to query Return whether or not the query is successful SMS_SetNewMessageStorage bool SMS_SetNewMessageStorage(SMS_Storage_t storage); Function Select the location of the newly received message store Parameters storage：The location of the new message storage Return Whether the new message storage location is set up successfully SMS_GetCharset const char* SMS_GetCharset(Charset_t charset); Function Getting the ASCII name of a specific character set Parameters charset：character set Return The ASCII name of the corresponding character set SMS_Unicode2LocalLanguage bool SMS_Unicode2LocalLanguage(uint8_t* unicodeIn, uint16_t unicodeLenIn, Charset_t localLanguage, uint8_t** localOut, uint32_t* localLenOut); Function Unicode to local language Parameters unicodeIn:unicode encoded messages unicodeLenIn:unicode encoded message length localLanguage: the local language to be converted into localOut: converts a good local language localLenOut: the converted local language length Return Whether or not the conversion is successful SMS_LocalLanguage2Unicode bool SMS_LocalLanguage2Unicode(uint8_t* localIn, uint16_t localLenIn, Charset_t localLanguage, uint8_t** unicodeOut, uint32_t* unicodeLenOut); Function Local language conversion to unicode coding Parameters localIn: local language message body localLenIn: the length of the local language message body localLanguage: local coding format unicodeOut: a converted Unicode encoded message body unicodeLenOut: the length of the converted Unicode encoding message body. Return Whether or not the conversion is successful "},"c-sdk/function-api/fota.html":{"url":"c-sdk/function-api/fota.html","title":"FOTA","keywords":"","body":"FOTA refer to demo: demo/fota Demo usage The demo is to receive upgrade firmware from the server to upgrade firmware or to receive firmware upgrade from the serial port upgrade. It should be noted that upgrading is based on differential upgrade. Every upgrade must be upgraded on the basis of the last firmware. ./build.bat clean to clean project edit code： Use serial or http server through comment or uncomment code // FOTA_UartTest(); FOTASERVER_Test(); If use http server, edit server address e.g.: #define SOFT_VERSION \"V3.0\" #define FOTA_HTTP_SERVER \"http://test.ai-thinker.com/csdk/fota/%stonew.pack\" so the V3.0tonew.pack is the new upgrade pack name ./build.bat demo fota compile old version firmware, fota_*_debug.lod and fota_*_debug_ota.lod can be find in hex/fota folder, back up fota_*_debug_ota.lod as old.lod,and back up hex/fota folder edit new version code,e.g.: #define SOFT_VERSION \"V3.0\" to #define SOFT_VERSION \"V3.1\" Compile new version, ./build.bat demo fota, and we get the same new firmware new.lod Generate a upgrade package: ./build.bat fota old.lod new.lod V3.0tonew.pack, the fourth parameter is the name of upgrade package, must the same as the upgrade link in the code(FOTA_HTTP_SERVER) Download the old version firmware(fota_*_debug.lod) to hardware, and wait auto upgrade from http server; If use serial should send upgrade file to serial. It will auto reboot after upgrade success. Then we can see the versioin upgrade to V3.1 from V3.0 "},"c-sdk/function-api/lbs.html":{"url":"c-sdk/function-api/lbs.html","title":"LBS","keywords":"","body":"LBS Get location(longitude & latitude) from base station infomation In some scenarios, it is necessary to use the latitude and longitude to determine the location of the module, but it does not require a very precise location. This time you can use the base station location to achieve this function without GPS. The principle of base station location is to get the base station information through the GSM module, and then send the base station information to the location server through GPRS. The server can return to the module after calculating the rough latitude and longitude according to the base station information. So if you need to use LBS, you can build your own server (recommended), and the GPRS module gets longitude and latitude information through long base station information. You can also use API in SDK, but just support China now. demo/lbs Function LBS_GetLocation bool LBS_GetLocation(Network_Location_t* bsInfo, uint8_t bsNumber,int timeoutS, float* longitude, float* latitude); 功能 Get location(longitude & latitude) from base station infomation, please ensure network activate complete already 参数 bsInfo: Base station infomation , Get by Network_GetCellInfoRequst bsNumber: The number of base station timeoutS: socket timeout time,unit:s longitude: longitude,unit:dgree latitude: latitude, unit:dgree 返回值 Is get location success "},"c-sdk/function-api/gizwits.html":{"url":"c-sdk/function-api/gizwits.html","title":"Gizwits","keywords":"","body":"Gizwits Gizwits makes development more efficient and easy, see more infomation about gizwits from gizwits official website example:demo/gizwits enum Gizwits_Action_t action number typedef enum{ GIZWITS_FIXED_LENGTH_ACTION_CONTROL = 0x01 , GIZWITS_FIXED_LENGTH_ACTION_READ_STATUS = 0x02 , GIZWITS_FIXED_LENGTH_ACTION_READ_STATUS_ACK = 0x03 , GIZWITS_FIXED_LENGTH_ACTION_REPORT_STATUS = 0x04 , GIZWITS_FIXED_LENGTH_ACTION_TRANS_RECV = 0x05 , GIZWITS_FIXED_LENGTH_ACTION_TRANS_SEND = 0x06 , GIZWITS_FIXED_LENGTH_ACTION_PUSH_OTA = 0xfe , GIZWITS_VARIABLE_LENGTH_ACTION_CONTROL = 0x11 , GIZWITS_VARIABLE_LENGTH_ACTION_READ_STATUS = 0x12 , GIZWITS_VARIABLE_LENGTH_ACTION_READ_STATUS_ACK = 0x13 , GIZWITS_VARIABLE_LENGTH_ACTION_REPORT_STATUS = 0x14 , GIZWITS_VARIABLE_LENGTH_ACTION_TRANS_RECV = 0x15 , GIZWITS_VARIABLE_LENGTH_ACTION_TRANS_SEND = 0x16 , GIZWITS_VARIABLE_LENGTH_ACTION_PUSH_OTA = 0xfe , GIZWITS_ACTION_MAX }Gizwits_Action_t; Struct Gizwits_Config_t Gizwits configuration, you must config imei,pk,pk_secret,alive，pk and pk_secret can be found in your gizwits app in gizwits website typedef struct { char imei[32]; char did[32]; char passcode[16]; char pk[48]; char pk_secret[48]; char hard_version[16]; char soft_version[16]; uint16_t alive; }Gizwits_Config_t; Gizwits_t Object of gizwits typedef struct{ Gizwits_Config_t* config; void* cloud; char* otaUrl; }Gizwits_t; Function OnReceivedOnePacket_Callback_t typedef void (*OnReceivedOnePacket_Callback_t)(Gizwits_t* gizwits, Gizwits_Action_t action,uint8_t* data, int len); function 数据接收回调函数 Parameters gizwits: Object of gizwits action: action of gizwits data: data received len: data length of received Return None GIZWITS_GetConfig bool GIZWITS_GetConfig(Gizwits_Config_t* config, const char* path); function Get the configuratio of gizwts Parameters config: configuration of gizwts path: config file path,e.g. \"/gizwits_config.conf\" Return Is get config success GIZWITS_Connect int GIZWITS_Connect(Gizwits_t* gizwits, Gizwits_Config_t* config, const char* configPath); function Connect gizwits,if no did,it will register, or just log in Parameters gizwits: Object of gizwits config: Configuration of gizwits configPath: Configuration file path of gizwits Return Return 0 if succeed connect to gizwits, or return error code GIZWITS_Send int GIZWITS_Send(Gizwits_t* gizwits, Gizwits_Action_t action, uint8_t* data, int len); function Publish data to gizwits Parameters gizwits: Object of gizwits action: Action data: Data need to send len: Length of data need to send Return Return 0 if succeed send to gizwits, or return error code GIZWITS_DoReceive int GIZWITS_DoReceive(Gizwits_t* gizwits, OnReceivedOnePacket_Callback_t onOnePacket); function Deal with the data received from gizwits, call after socket received data Parameters gizwits: Object of gizwits onOnePacket: data incomming callback function Return Return the length of raw data received GIZWITS_Ping bool GIZWITS_Ping(Gizwits_t* gizwits); function Send heart beat packet to gizwits, you must call it within alive time in configuration, or the server will force to close the connection Parameters gizwits: Object of gizwits Return Is send heart beat packet success GIZWITS_GetSocket int GIZWITS_GetSocket(Gizwits_t* gizwits); function Get the file description of socket that connected to gizwits Parameters gizwits: Object of gizwits Return socket fd, > 0 GIZWITS_Close bool GIZWITS_Close(Gizwits_t* gizwits); function Close connect with Gizwits Parameters gizwits: Object of gizwits Return Is succeed to close Gizwits "}}