{"./":{"url":"./","title":"关于本文档","keywords":"","body":"Ai-Thinker GPRS C SDK 文档 Ai-Thinker SoC development GPRS C SDK documention 安信可GPRS模组片上(SoC)开发C语言版SDK文档 CSDK代码：GPRS_C_SDK 文档源码：GPRS_C_SDK_DOC 点我在线阅读文档 ( Read English ) 关于模组 安信可GPRS模组型号主要有A9，A9G。 A9主要有GSM/GPRS（2G)相关功能；A9G除了GSM/GPRS还集成了定位芯片，方便定位相关的应用，更多功能介绍请看硬件介绍章节 模组样品都可以在淘宝购买到：淘宝链接 开发 模组的开发主要提供两种接口： （一） AT接口 即需要外接MCU使用串口来操作模组 这种方式操作较简单，是需要让模块实施什么动作通过串口向模块发送一个命令即可，这个命令就是一串字符串，具体哪个命令是什么字符串，查AT文档即可，适合刚入门的开发者 模组出厂默认烧录的就是AT固件，拿到模组就可以操作，资料参见这里：安信可wiki 本文档不涉及任何AT操作 （二）SDK片上开发(SoC开发/SDK二次开发) 不需要外接MCU，直接写GPRS模组的固件，对GPRS模组进行编程. A9/A9G GPRS模块使用RDA8955作为主芯片,主频能达到312MHz,除了跑协议栈之外,还有很多空余的资源可以使用,非常适合拿来进行二次开发,可以满足大多数应用需要,但是不建议跑实时性要求非常高的控制类应用 这种方式的优点是不用再外接MCU，直接对模组编程，节约了硬件资源，适合对硬件成本要求高的场景 本文就是使用这种方式，详细介绍如何使用SDK进行开发，并提供相关API说明 本SDK中不包含AT应用及接口,所有操作均通过SDK接口调用 "},"ying-jian/a9.html":{"url":"ying-jian/a9.html","title":"A9","keywords":"","body":"A9 特征： 32位内核，主频高达312MHz，4k指令缓存，4k数据缓存 多达29个GPIO（两个GPIO作为下载口） 实时时钟、闹钟 1个USB1.1接口 2个带流控的UART接口（+1个下载调试串口） 2个SPI接口 3个I2C接口 1个SDMMC控制器（接口） 2个10位ADC接口 32Mb(4MB) SPI NOR Flash 32Mb(4MB) DDR PSRAM 8kHz、13Bits/sample ADC mic 48kHz、16bits/sample DAC Audio 电源管理单元：锂电池充电管理、集成DC-DC及LDOs、可变化的IO电压 18.8 x 19.2 mm SMD封装 四频GSM/GPRS（800/900/1800/1900MHz) 语音通话 短信服务 硬件 规格书：A9规格书 用户手册：A9/A9G用户手册 硬件资料文件：A9/A9G硬件资料 模组引脚图(硬件资料文件中也包含)(A9和A9G模组引脚兼容) "},"ying-jian/a9g.html":{"url":"ying-jian/a9g.html","title":"A9G","keywords":"","body":"A9G 特征： A9所有特征 模组内集成GK9501芯片，可实现实时定位，内部与GPRS芯片串口2相连 硬件 GPRS 使用RDA8955作为主控芯片，内部集成了GSM/GPRS等协议栈 规格书：A9G规格书 用户手册：A9/A9G用户手册 硬件资料文件：A9/A9G硬件资料 模组引脚图(硬件资料文件中也包含)(A9和A9G模组引脚兼容) GNSS(GPS) GK9501：一款高性能、高集成度、低功耗、低成本的多模卫星定位导航芯片，支持BDS/GPS/GLONASS/GALILEO/QZSS/SBAS。 GK9501文档及工具：下载地址: 百度云 文件包含： 可视化调试工具naviTrack及使用文档 固件更新程序及使用文档 输入输出格式文档及AGPS文档 "},"ying-jian/kai-fa-ban-pudding.html":{"url":"ying-jian/kai-fa-ban-pudding.html","title":"开发板pudding","keywords":"","body":"开发板pudding 特征： 1个A9G模块（A9和A9G采用相同封装，引脚相同,所以开发板通用） 引出模块29个GPIO（包括2个下载调试引脚（HST_TX,HST_RX） 1个SIM卡（Micro卡）卡槽(Nano卡 1个TF卡卡槽 1个GPRS IPEX1代座子 1个GPS IPEX1代座子 一个USB接口 5v-4.2V DC-DC，故可以5v供电或者3.8~4.2V供电 1个加速度计LIS3DHx芯片 1个开机按键，1个复位按键 2个连接到GPIO的LED灯 1个麦克风 引脚图 原理图 A9原理图：http://wiki.ai-thinker.com/_media/gprs/a9/a9-dev_v1.2.pdf A9G原理图：http://wiki.ai-thinker.com/_media/gprs/a9g/a9g-dev_v1.2.pdf A9原理图库：http://wiki.ai-thinker.com/_media/gprs/a9g/a9g-dev_v1.2.zip A9G原理图库：http://wiki.ai-thinker.com/_media/gprs/a9/a9-dev_v1.2.zip "},"ying-jian/usbzhuan-chuan-kou-mo-kuai.html":{"url":"ying-jian/usbzhuan-chuan-kou-mo-kuai.html","title":"USB转串口模块","keywords":"","body":"USB转串口模块 下载程序到开发板是通过串口进行下载，需要一个USB转串口芯片，在淘宝可以买到 不建议使用PL2303或者CH34芯片的USB转串口模块，可能会出现驱动问题或承载电流不够的问题 可以使用cp2102，购买链接：安信可USB转串口模块 "},"ying-jian/simqia.html":{"url":"ying-jian/simqia.html","title":"SIM卡","keywords":"","body":"SIM卡 在GSM/GPRS网络中为了保证每个设备身份的唯一性，都需要一张SIM卡。 现在主要有实体SIM卡和eSIM，前者是一张带芯片和触点的卡片，有不同的大小：标准SIM、Micro SIM、Nano SIM；后者是一个芯片，体积很小可直接安装在设备内部。 开发板pudding使用micro SIM卡 "},"ji-chu-zhi-shi/gsmgprs.html":{"url":"ji-chu-zhi-shi/gsmgprs.html","title":"GSM/GPRS","keywords":"","body":"基础知识：GSM/GPRS GSM 全球移动通讯系统（Global System for Mobile Communications) GPRS 通用分组无线业务(General Packet Radio Service) GPRS是在GSM系统基础上发展起来的分组数据承载和传输业务,GSM是一种电路交换系统，而GPRS是一种分组交换（包交换）系统。 关于GPRS这里简单介绍它的几个简单的重要知识，更多详细请自行找资料学习 （1）GPRS服务种类 GPRS服务种类分为Class A/B/C， Class A：是能同时支持电路交换和分组交换（即可以同时打电话和上网） Class B：支持电路交换和分组交换，但是只能同时进行一种 Class C：只支持分组交换 （2）GPRS的传输类型 GPRS网络为每个用户分配最多8个时隙来传输数据，这最多8个时隙又由上行和下行组成，具体分为以下几类： Class 2：下行2，上行1 （简称2+1） Class 4：下行3，上行1 （简称3+1） Class 8：下4，上行1 （简称4+1） Class 10：下行4，上行2 （简称4+2） Class 12：下行4，上行4 （简称4+4） 这里需要注意的是Class 8/10/12并不是指有8/10/12个信道可以使用，它们的总信道都只有5个，这里的分类说明了最大可以使用的上行信道和下行信道数。 GPRS传输速度：理论上class值越大速度越快，但是速度受基站和GPRS设备（GPRS模组、手机）双方的最低速度限制，比如GPRS设备支持Class 12，但是基站只支持Class 10，那就会收到Class 10限制，而且和编码方式、信号、干扰等因素也有关系。 （3）GPRS编码方式 GPRS定义了CS-1到CS-4四种信道编码方式，不同编码方式速率不同，纠错能力也不同。编码方式越低，纠错能力越强，但是速率越低，所以在信号越好的地方使用更高的编码方式。 （4）GPRS建立数据通信流程 GPRS设备连接基站并注册(register)到网络，保证有足够强的信号,此时便可以使用GSM服务，即可以通话、短信。 GPRS附着（Attach）：建立GPRS设备到GPRS网络的通信信道，实际上是附着到SGSN(serving GPRS support node)上。 GPRS PDP Context(分组报文协议上下文)激活：可以将这一步看作是GPRS设备从网关拿到IP地址，经过这一步设备便具有数据通信功能,能够与公网设备建立通信。 GGSN(gateway GPRS Support Node)是GPRS网络中的关键部分，是GPRS网络和外部分组交换网络之间的交互，从外部网络来看，GGSN就是一个子网路由器，负责交换SGSN与外部网络之间的信息，还负责认证、流量计费等功能。 与公网设备建立连接：因为设备已经建立好于公网的连接，只需要直接通过某种协议连接即可，比如建立TCP连接、UDP连接等 IMEI SN IMSI CCID区别 SN是模块序列号,一般情况可以不用理会 IMEI是设备号码,全球唯一,会发送到基站网络进行校验,在一些地区如果IMEI号码错误可能导致无法联网 IMSI： International Mobile SubscriberIdentification Number 国际移动用户识别码，是区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息。其总长度不超过15位，同样使用0～9的数字。其中MCC是移动用户所属国家代号，占3位数字，中国的MCC规定为460；MNC是移动网号码，最多由两位数字组成，用于识别移动用户所归属的移动通信网；MSIN是移动用户识别码，用以识别某一移动通信网中的移动用户。例如开头是46000是中国移动用户，46001是联通用户，46003是电信用户 ICCID：Integrate circuit card identity 集成电路卡识别码（固化在手机SIM卡中),ICCID为IC卡的唯一识别号码，共有20位数字组成 "},"ji-chu-zhi-shi/gps.html":{"url":"ji-chu-zhi-shi/gps.html","title":"GNSS(GPS)","keywords":"","body":"基础知识：GNSS(GPS) GNSS Global Navigation Satellite System(全球卫星导航系统)，是全球卫星导航系统的统称，大家常说的GPS只是其中的一种定位系统，如下： GPS: Global Positioning System，全球定位系统，由美国研制，全球覆盖率高达98%，共24颗卫星。全球最早研制并投入使用的定位系统 BDS: 中国的北斗卫星导航系统（BeiDou Navigation Satellite System） GLONASS: 来自俄罗斯 Galileo: 欧洲的伽利略系统（ satellite navigation system） QZSS: 日本组建的定位系统。 SBAS: 除了卫星定位系统，还有SBAS（Satellite-Based Augmentation System），即星基增强系统，通过地球静止轨道（GEO）卫星搭载卫星导航增强信号转发器，可以向用户播发星历误差、卫星钟差、电离层延迟等多种修正信息，实现对于原有卫星导航系统定位精度的改进，从而成为各航天大国竞相发展的手段。目前，全球已经建立起了多个SBAS系统，如美国的WAAS（Wide Area Augmentation System）、俄罗斯的SDCM（System for Differential Corrections and Monitoring）、欧洲的EGNOS（European Geostationary Navigation Overlay Service）、日本的MSAS（Multi-functional Satellite Augmentation System）以及印度的GAGAN（GPS Aided Geo Augmented Navigation） 坐标系WGS84,CGCS2000 定位离不开的肯定是坐标系，GPS使用的坐标系是WGS84（World Geodetic System 1984）坐标系，除了WGS84之外，中国还有CGCS2000(国家大地坐标系)。 坐标偏移标准GCJ-02 BD-09 除了有多个坐标系外，还有坐标偏移标准，大众使用的地图上的坐标都不是原生的WGS84或CGCS2000坐标，都是对原始坐标加入随机偏移再加密后的坐标。 偏移标准主要有GCJ-02(国家测绘局02号标准)（火星坐标），还有BD09(百度坐标)。 所以鉴于有多重坐标系以及坐标偏移标准，在使用位置信息是一定要十分注意，获取到的数据是什么坐标，按照自己的需求进行转换 比如A9G模块输出的坐标是WGS84坐标，得到坐标后想显示到百度地图，则需要将WGS84坐标转换成BD09坐标，如果显示到高德地图则需要转换成火星坐标，否则地图上显示的位置可能会有非常大的误差！！！ "},"c-sdk/kai-fa-huan-jing-an-zhuang.html":{"url":"c-sdk/kai-fa-huan-jing-an-zhuang.html","title":"Windows开发环境安装","keywords":"","body":"GPRS C SDK 开发环境搭建 注意 重要，请先阅读 SDK没有特定的IDE，用户自己选择代码编辑器编辑代码。 在修改代码时，一定不能使用windows自带的记事本和写字板，请使用更加专业的编辑器(推荐使用如vscode，sublime，atom，eclipse,source insight等，或者其它你熟悉的编辑器。) 比如使用VS Code, 它支持函数跳转等基本功能(在vscode里面搜索C/C++插件安装),多使用搜索功能(侧边栏搜索图标)会很方便 请修改编辑器设置，文件结尾符号设置为unix风格((\\n)结尾)(设置方法请自行到网络查找) 如果你是使用git进行克隆，请设置git在pull时不将转换为，设置方法参考这里 下载工具链以及下载调试工具及SDK 下载CSDTK4.2：百度云下载，MEGA网盘下载，直接链接 下载SDK 注意： 下载完请检查platform/csdk文件夹下是否包含debug、release文件夹，没有说明下载文件不全，请重新下载完整的SDK 如果使用git克隆，因为工程使用了子模块，请添加--recursive参数，否则克隆下来的文件不全无法编译成功 安装 解压到某个文件夹,比如C:\\CSDTK,路径请不要带中文！ 运行CSDTk目录下的config_env_admin.bat文件来设置环境变量 这个脚本做的事情就是新建一个名为GPRS_CSDTK42_PATH的环境变量，变量值为CSDTK的目录路径。 如果脚本建立失败也可以自己手动建 编译 解压下载到的CSDK为GPRS_C_SDK文件夹放到某个目录下，比如C:\\GPRS_C_SDK，请使用下划线(_)而不是减号(-) 进入CSDK文件夹（C:\\GPRS_C_SDK），按住shift，在文件夹内空白处鼠标右键单击，选择cmd打开或者powershell打开，如图： 使用./build.bat app 或者 build.bat app来编译工程，测试环境是否可用，如果正常，会出现以下结果： 如果提示NO CSDTK,Please install CSDTK first!，则是环境变量没有生效（在win7下可能会出现），可以重启电脑以生效 保证环境可以使用后，就可以在CMD或powershell窗口中使用build.bat脚本来编译工程，有以下参数： 使用 ./build.bat $PROJ来编译你的应用模块，如 ./build.batsh app 则是编译app目录下的源码 使用 ./build.bat demo $PROJ 来编译demo目录下的特定例程，比如./build.bat demo gpio 使用 ./build.bat clean $PROJ 清除$PROJ目录的中间文件 使用 ./build.bat clean all 清除所有中间文件 使用 ./build.bat demo $PROJ release 来生成release版本，比如./build.bat demo gpio release， 如果最后一个参数不是release，则默认是debug版本， debug版本在死机后会停止运行并可以使用GDB调试，而release版本加入了看门狗功能，在死机时会自动重启系统，所以实际投入使用时请使用release版本以防止出现bug时死机，测试时使用debug版本 比如： ./build.sh demo gpio 进行编译，编译会生成一个build目录，编译完成会在hex目录下生成两个格式为lod的文件，这就是我们用来下载到开发板的目标文件 目标文件说明 两个文件一大一小，在第一次下载时需要下载大文件(*_B*.lod)即可，第二次和以后为了减少下载时间都只需要下载小文件(*_flash.lod)即可，更新SDK后需要重新下载大文件 其它问题 如果遇到问题，请仔细对比文档，看操作是否有错，也可以在issue里找有没有先例，如果仍然有错，可以到安信可论坛提问或者github提交issue 方式一：github添加issue 方式二：安信可论坛讨论 "},"c-sdk/installation_linux.html":{"url":"c-sdk/installation_linux.html","title":"Linux开发环境安装","keywords":"","body":"GPRS C SDK Build environment installation on Linux Pay Attention important, please read first SDK does not have a specific IDE, and the user chooses the code editor to edit the code.(Like vscode, sublime, atom, eclipse, source insight, or other editors you are familiar with. ) Please modify the editor settings. The end of the file symbol is set to UNIX style ( (\\n) end), and file encoding is UTF-8 if you are cloned using git, set the git at pull not to convert to , set the method reference here Download tool chain, debug tool and SDK Download CSDTK4.2 Linux version: baidu cloud MEGA cloud direct link Get SDK download SDK or clone by git:git clone https://github.com/Ai-Thinker-Open/GPRS_C_SDK.git --recursive (pay attention --recursive is needed, or compile will fail for lake of files) Check C_SDK platform/csdk folder, there should be some folders and file, if not, you may get source code with wrong way, check and download again Installation Install dependences for compile tool sudo apt install build-essential gcc-multilib g++-multilib libzip-dev zlib1g lib32z1 Install dependences for coolwatcher sudo apt install build-essential libqt4-qt3support itcl3 itk3 iwidgets4 and maybe other compatible libs in ther latest ubuntu sudo apt install libpng12-0 libusb-0.1-4 CSDTK set up Create a project folder e.g. ~/projects mkdir ~/projects Decompress CSDTK42_Linux.tar.gz to a folder, ~/software/CSDTK for example, and then execute setup.sh, the first parameter is the location of CSDTK, the second parameter is the location of your projects cd ~/software tar -xzvf CSDTK42_Linux.tar.gz cd CSDTK ./setup.sh ./ ~/projects Compile Decompress the CSDK downloaded to GPRS_C_SDK folder into a directory, such as ~/projects/GPRS_C_SDK, use the underscore(_) instead of minus(-). Check if the SDK have full files, check platform/csdk folder, if no debug and release folders, you download the wrong SDK file, please download again in release page or clone by command git clone https://github.com/Ai-Thinker-Open/GPRS_C_SDK.git --recursive compile cd ~/projects/GPRS_C_SDK ./build.sh demo gpio if you put you GPRS project in the projects folder(you set by command ./setup.sh ./ ~/projects before), you can use a script to go to the project folder quikly as follow work GPRS_C_SDK ./build.sh demo gpio Then you can use ./build.sh script to build project: ./build.sh $PROJ:compile app module，e.g.:./build.sh app to compile the source code of app folder ./build.sh demo $PROJ:compile demo project, e.g.:./build.sh demo gpio to compile gpio demo ./build.sh clean $PROJ:clear the build files of $PROJ ./build.sh clean all:clear all the build files ./build.sh demo $PROJ release:build a release version, e.g.:./build.sh demo gpio release，if the last parameter is not release, it will be default to debug version. The GDB can be used to debug errors after system crashed in debug version, but release version can not, watch dog activate in release version,it will auto restart system when system crashed! e.g.: ./build.sh demo gpio A build folder will be generated after compile, there's two *.lod files in th hex folder, it's the target file that burn(download) to dev board about target hex file(*.lod) There's two hex file,(*_B*.lod and *_flash.lod), you must burn the bigger one to dev board at the first time, then you can just burn the little one to reduce the doanload time. And you must download the bigger if you update the SDK version Other Problems If error occured, please compare the documents carefully to see if the operation is wrong，and find in issue Way A: github add issue Way B: Ai-Thinker forum "},"c-sdk/installation_docker.html":{"url":"c-sdk/installation_docker.html","title":"使用docker编译","keywords":"","body":"Docker compile environment 如果你还不知道什么是docker，可先不用理会，等你有兴趣了再回来了解 Docker build environment for Ai-Thinker A9/A9G (RDA8955) We can do more awsome works by docker image, e.g. Set up build evironment faster and easier without affecting the host (physical machine/PC) environment Make automatic testing/build easier See here to start "},"c-sdk/xia-zai-bian-yi-hao-de-gu-jian-dao-mo-zu.html":{"url":"c-sdk/xia-zai-bian-yi-hao-de-gu-jian-dao-mo-zu.html","title":"下载固件到模组及调试","keywords":"","body":"GPRS 下载调试说明 硬件连接 模块的调试下载接口是HST接口，即引脚HST_RX和HST_TX脚分别连接连接USB转串口模块的TX和RX引脚（交叉连接,HST_RX接TX） 电源可以接锂电池电压（即3.8v~4.2v）（VBAT引脚）,也可以接5v电源（5v输入引脚或者USB输入），需要注意的是，如果使用锂电池供电，上电后需要按POWER KEY3秒左右让模块开机，USB供电则会上电自动开机。 在下载或者调试时要确保已经开机。 Linux Install dependences sudo apt install build-essential libqt4-qt3support itcl3 itk3 iwidgets4 Create a link file for serial port as follow, and later you can fill in the coolwatcher's chart with 1,the COM1 must upper-case sudo ln -s /dev/ttyUSB0 comport/COM1 Then double click coolwatcher to run software 下载步骤 将coolwatcher更新到最新版本(coolwatcher在CSDTK文件夹下) 打开CSDTK/cooltools/coolwatcher.exe 左边profiles选项选择8955，右边需要设置lastcomport为连接模块下载调试串口(HST)的端口 点击Ok 等待连接成功，出现以下界面 如果出现连接失败的情况，请参考 coolwatcher 无法连接原因部分 如果第一次使用，需要点击DRY图标，选择名字包含8955 ramrun spi32m .lod的文件（在工程platform/ramrun下或者coolwatcher cooltools\\chipgen\\Modem2G\\toolpool\\plugins\\fastpf\\flash_programmers目录下）。 只需要设置一次，后面都会记住的 点击下图中的lod图标，选择编译生成的固件，在工程hex目录下.lod格式的文件，首次下载下载文件体积较大的.lod格式文件，后面为了加快下载速度只需要下载体积较小的固件文件即可 点击 download图标，进行下载，正常效果如下图，右下角Command栏会有进度标志 如果下载失败，请参考 coolwatcher 下载失败原因部分 coolwatcher无法连接 解决方法： 保证串口和模块已经连接（注意开发板上的USB口不是串口，下载串口是通过USB转串口模块连接HST_RX 和 HST_TX引脚，注意是交叉连接，即GPRS模块的HST_RX连接USB转串口模块的TX） 保证串口没有被其它软件占用 检查串口号是否选择错误，重新启动的时候设置串口号，或者不重启 点击右下角CoolHost图标来设置 然后点击connect重新连接串口 coolwatcher无法下载 ramrun文件错误，分别尝试使用工程目录platform/ramrun下 和 coolwatcher CSDTK\\cooltools\\chipgen\\Modem2G\\toolpool\\plugins\\fastpf\\flash_programmers目录下的*_8955_*_spi32m_ramrun.lod 有可能程序进入了休眠模式，按模块复位键复位后再下载 串口有可能掉了，任务栏右下角双击CoolHost图标重新连接串口，再下载 串口其它问题，拔掉USB转串口模块重新插入电脑，再进行上一步重新连接串口 程序中开机就进入了睡眠模式 或者 有线程使用了while(1)死循环而且完全占用了资源，比如: void LoopTask(VOID *pData) { uint64_t count = 0; while(1) { ++count; if(count == 3000) { count = 0; Trace(1,\"Test Test\"); } } } 解决： 按下模块复位键，在USB转串口模块数据传输指示灯闪烁（即模块已经启动并向串口发送数据）的一瞬间按下下载按钮即可，不行就多试几次 为了彻底防止这种问题，建议不要写这种程序，在循环中最好使用事件触发或者至少延时OS_Sleep())一下，比如： void LoopTask(VOID *pData) { uint64_t count = 0; while(1) { ++count; if(count == 3000) { count = 0; Trace(1,\"Test Test\"); OS_Sleep(100); } } } 或 void LoopTask(VOID *pData) { uint64_t count = 0; while(1) { ++count; if(count == 3000) { count = 0; Trace(1,\"Test Test\"); } } OS_Sleep(1); } 或 事件处理 void AppMainTask(VOID *pData) { API_Event_t* event=NULL; while(1) { if(OS_WaitEvent(mainTaskHandle, &event, OS_TIME_OUT_WAIT_FOREVER)) { EventDispatch(event); OS_Free(event->pParam1); OS_Free(event); } } } 调试 Tracer基本介绍及使用 查看debug信息：打开Plugins->Active Tracer，界面及功能如下图 使用前需要设置Tracer，设置如下如1~6步： 程序中需要输出调试信息可以调用api_debug.h中的bool Trace(uint16_t nIndex,const char* fmt, ...)函数，其中 nIndex就是对应tracer设置中的MMI 01 ~ MMI 16 Tracer使用容易遇到的问题 有时候自己期望的调试数据没有显示，有可能是点了右上角的暂停显示最新的按钮，忘了关闭！！ 刚开机的时候Trace模块可能还没启动完成，可能会出现开始部分信息没有打印的情况 死机处理 这里模拟了一个异常，空指针赋值的异常，一般出现这种问题都是指针乱飞的问题！ 打开GBD，并设置选择elf文件 打开GBD终端，输入bt 或者bt f查看信息 需要注意的是，这个GDB并不是在并不支持手动打断点功能，打断点需要在代码中写入断点语句才行，所以只用它来查看死机信息就行了，当死机后再用它！ 如果觉得这个GDB调试功能不是很好用，可以用打印调试信息的方式来调试bug 如果遇到问题，参见文档中的常见问题，也可以在issue里找有没有先例 "},"c-sdk/kai-shi-di-yi-fen-dai-ma.html":{"url":"c-sdk/kai-shi-di-yi-fen-dai-ma.html","title":"开始第一份代码","keywords":"","body":"开始第一份代码 确保可以编译代码、下载固件到GPRS模块/开发板后，就可以开始了解如何写一份代码啦~~~~ 以下的代码可以在工程目录demo/first中找到 作为第一份代码，当然是从我们熟悉的hello wold做起呀~~~ 所以我们的目标：一个完整的代码架构，并能不断间隔打印Hello GPRS即可 目录 目录 描述 app 程序主目录，应用代码放在这里 build 编译生成的目录、中间文件 demo 一些例程 doc 相关文档，Markdown格式 hex 最后产生的可烧录文件 include SDK头文件目录，可以在这里面找需要的API以及函数、参数注释 init 系统初始化的目录，可以不用理会，不建议改动 platform 库文件等，请确保platform/csdk文件夹不为空 建立文件夹、文件 新建demo/fisrt文件夹，并新建Makefile文件，注意只是首字母大写，或者全是小写 填入以下内容： # Name of the module LOCAL_NAME := demo/first # List of submodules which contain code we need to include in the final lib LOCAL_API_DEPENDS := \\ LOCAL_ADD_INCLUDE := include\\ include/std_inc \\ include/api_inc \\ # Set this to any non-null string to signal a module which # generates a binary (must contain a \"main\" entry point). # If left null, only a library will be generated. IS_ENTRY_POINT := no ## ------------------------------------ ## ## Add your custom flags here ## ## ------------------------------------ ## MYCFLAGS += ## ------------------------------------- ## ## List all your sources here ## ## ------------------------------------- ## C_SRC := ${notdir ${wildcard src/*.c}} ## ------------------------------------- ## ## Do Not touch below this line ## ## ------------------------------------- ## include ${SOFT_WORKDIR}/platform/compilation/cust_rules.mk 这里LOCAL_NAME := demo/first填文件夹路径，LOCAL_ADD_INCLUDE是包含的头文件路径 新建demo/first/src文件夹,并新建demo_first.c文件 代码 代码可以在工程目录demo/first/src/demo_first.c中找到 主要要做的事情是:编写程序入口，并创建主任务，用来接收来自底层的事件,同时建立一个任务,不停打印信息 入口及主任务 程序入口，创建主任务（这里使用到了操作系统相关的函数，如果没有接触过，请不要惧怕，可以先照着做） #include \"stdbool.h\" #include \"stdint.h\" #include \"api_os.h\" #include \"api_debug.h\" #include \"api_event.h\" #define MAIN_TASK_STACK_SIZE (2048 * 2) #define MAIN_TASK_PRIORITY 0 #define MAIN_TASK_NAME \"Main Test Task\" static HANDLE mainTaskHandle = NULL; void first_Main(void) { mainTaskHandle = OS_CreateTask(MainTask, NULL, NULL, MAIN_TASK_STACK_SIZE, MAIN_TASK_PRIORITY, 0, 0, MAIN_TASK_NAME); OS_SetUserMainHandle(&mainTaskHandle); } 每个程序都有一个入口，这里的入口是一个函数： void first_Main(void)，返回值和参数都是void，下划线左边必须是文件夹的名字，这里是first，下划线右半边必须是Main，首字母大写。 调用OS_CreateTask来创建一个任务，具体参数含义可以见OS部分，这里先不阐述。调用OS_SetUserMainHandle将刚刚创建的任务指针（句柄）传给底层，让底层知道给那个任务发送事件，这个是必须的 主任务处理及打印任务 #define SECOND_TASK_STACK_SIZE (2048 * 2) #define SECOND_TASK_PRIORITY 1 #define SECOND_TASK_NAME \"Second Test Task\" static HANDLE secondTaskHandle = NULL; void SecondTask(void *pData) { while(1) { Trace(1,\"Hello GPRS \"); OS_Sleep(3000); } } void EventDispatch(API_Event_t* pEvent) { switch(pEvent->id) { default: break; } } void MainTask(void *pData) { API_Event_t* event=NULL; secondTaskHandle = OS_CreateTask(SecondTask, NULL, NULL, SECOND_TASK_STACK_SIZE, SECOND_TASK_PRIORITY, 0, 0, SECOND_TASK_NAME); while(1) { if(OS_WaitEvent(mainTaskHandle, (void**)&event, OS_TIME_OUT_WAIT_FOREVER)) { EventDispatch(event); OS_Free(event->pParam1); OS_Free(event->pParam2); OS_Free(event); } } } 主任务MainTask中又新建了一个任务SecondTask，这个任务中做的事情就是每间隔3秒钟打印一句Hello GPRS，打印信息可以在coolwatcher的tracer工具中看到； 然后主任务阻塞等待来自底层的事件，并在EventDispatch函数中处理，这里暂时没有处理任何事件，所有事件可以在api_event.h中找到，每个事件的参数也有注释 编译并下载固件看验证 按照前面的编译、下载方法下载到开发板运行，打开调试工具可以看到打印的Hello GPRS "},"more/vscode.html":{"url":"more/vscode.html","title":"如何使用vscode写C代码","keywords":"","body":"如何使用vscode提高查看代码和写代码效率 下载vscode: https://code.visualstudio.com , 并安装 选择 文件--> 打开文件夹, 打开工程文件夹(比如这里的GPRS_C_SDK) 左边侧边栏点击c源文件, vscode会自动识别到是c文件,会自动采用c语言语法高亮,右下角会自动识别文档格式(比如GPRS_C_SDK使用UTF-8),以及行结尾符为LF(即\\n) 第一次打开c文件,vscode会提示安装C/C++扩展,这个扩展可以为vscode添加右键函数跳转等其它IDE中有的基本功能 打开C文件会提示安装C/C++扩展,如果没有安装,可以在左边侧边栏扩展选项中搜索C/C++然后安装,安装完成后点击重载页面即可 查看代码和编写代码时,如果需要查看函数定义,可以使用右键转到定义,查看头文件可以右键Peek Declaration, 如果找不到,可以多使用Ctrl+F来搜索文件, 以及使用左边栏的搜索按钮(或者快捷键Ctrl+Shif+F)来搜索整个工程, 使用C/C++插件的跳转功能以及文件搜索和全局搜索这几个功能, 可以大大提高代码阅读和编写效率 左边有大纲,可以看到代码的大纲 更多有意思的功能有兴趣可自行探索,比如集成了git版本管理,可以很方便地对比文件更改 "},"c-sdk/dai-ma-feng-ge-ji-ming-ming-gui-ze.html":{"url":"c-sdk/dai-ma-feng-ge-ji-ming-ming-gui-ze.html","title":"代码风格及结构","keywords":"","body":"代码风格及目录结构 目录结构 主要由以下几个文件夹组成： app： 用户程序文件夹 demo：例示程序 include: 头文件夹 init：初始化代码，不建议改动 platform：库文件相关 相关API都可以在include文件夹中找到，对应的实例都可以在demo文件夹中找到。 所有来自底层的事件均可以在api_event.h中找到，并且事件参数的含义都在对应事件后面的注释说明。 代码风格 统一的代码风格方便阅读，对于任何一份代码来说都十分重要，每个人的代码风格不尽相同，但是多人在开发同一份代码时一定要统一风格，一份简洁干净的代码会让编码更加顺利舒畅~ CSDK使用统一的代码风格，简要概括为以下几个点： 函数命名 模块API使用大写功能模块_大驼峰命名，比如AUDIO_MicOpen，SSL_Init；普通函数使用大驼峰命名，比如：EventDispatch 入口函数特殊，使用文件夹名字_Main，比如imei_Main 变量命名 小驼峰命名，比如：int ballNumber; 宏定义 大写+下划线，比如：#define BUFFER_MAX_LENGTH 10 文件编码格式 文件编码统一为UTF-8无BOM格式 tab还是空格？ 不使用tab，编辑器设置tab为4空格替换 单词缩写 对于一些业界熟知的单词可以尽量使用缩写，比如src、tmp等， 除了这些之外，为保证代码的可读性，务必使用全称，特别是一些专业术语，尽量让没有接触过这个单词的人通过搜索引擎能够搜到这个单词的含义。 比如： NetworkLocation，如果缩写成NL、NetLo，相信就算是对这个单词非常熟悉的人也得去看代码的上下文才能慢慢才到其中的含义！如果去网上搜索这几个缩写，也不可能得到NetworkLocation！ 所以，为了让代码更简洁清晰易读，不一定是要让代码单词缩写为更简单的形式，相反的是全称的单词往往更易读。 另外，有些单词需要进行解释，需要适量进行注释 注释 注释可以使用/**/或者//进行注释，失效的代码尽量使用/**/注释 需要加入到自动生成文档的说明用 ////////////// ///这里写注释 ////////////// 或者 /** *这里写注释 * */ 文件注释或函数等注释可以适当加相关信息，比如文件： /** *@file header.h *@author nick name */ 或函数 /** *@brief 这里写简要说明，@brief可以省略,省略则将简要说明写在注释开头 *@param a 求和参数1 *@param b 求和参数2 *@return 返回和 */ "},"c-sdk/gong-neng-ji-api.html":{"url":"c-sdk/gong-neng-ji-api.html","title":"功能及API","keywords":"","body":"功能及API 可以根据自己的需求查找相关模块的使用方法 也可以在SDK demo目录下找到更多例程,可以参考使用 功能及API "},"c-sdk/gong-neng-ji-api/gpio.html":{"url":"c-sdk/gong-neng-ji-api/gpio.html","title":"GPIO","keywords":"","body":"GPIO (General Purpose Input Output)通用输入输出接口 要保证引脚功能可以正常使用，在配置IO之前必须将对应IO口的电源打开，使用 bool PM_PowerEnable(Power_Type_t powerType, bool isOn) ```c 函数来打开对应的IO口电源,不同IO口对应的电源如下： ```c typedef enum{ POWER_TYPE_VPAD = 0, // GPIO0 ~ GPIO7 and GPIO25 ~ GPIO36 2.8V //always on POWER_TYPE_MMC, // GPIO8 ~ GPIO13 1.9V POWER_TYPE_LCD, // GPIO14 ~ GPIO18 1.9V POWER_TYPE_CAM, // GPIO19 ~ GPIO24 1.9V POWER_TYPE_MAX }Power_Type_t; 比如： 需要使用GPIO5，则需要调用PM_PowerEnable(POWER_TYPE_VPAD,true); 需要调用I2C2,因为I2C2是复用IO19和20，所以调用PM_PowerEnable(POWER_TYPE_CAM,true); 模组引脚除了通用IO功能外，部分引脚还有复用功能，具体见开发板中的引脚图 例示代码请参考CSDK demo/gpio 枚举类型 GPIO_PIN 引脚 typedef enum{ GPIO_PIN0 = 0, //IO 可中断 GPIO_PIN1, //IO 可中断 GPIO_PIN2, //IO 可中断 GPIO_PIN3, //IO 可中断 GPIO_PIN4, //IO 可中断 GPIO_PIN5, //IO 可中断 GPIO_PIN6, //IO 可中断 GPIO_PIN7, //IO 可中断 GPIO_PIN8, GPIO_PIN9, GPIO_PIN10, GPIO_PIN11, GPIO_PIN12, GPIO_PIN13, GPIO_PIN14, GPIO_PIN15, GPIO_PIN16, GPIO_PIN17, GPIO_PIN18, GPIO_PIN19, GPIO_PIN20, GPIO_PIN21, GPIO_PIN22, GPIO_PIN23, GPIO_PIN24, GPIO_PIN25, GPIO_PIN26, GPIO_PIN27, GPIO_PIN28, GPIO_PIN29, GPIO_PIN30, GPIO_PIN31, GPIO_PIN32, GPIO_PIN33, GPIO_PIN34, GPIO_PIN_MAX }GPIO_PIN; GPIO_MODE IO模式 typedef enum{ GPIO_MODE_OUTPUT = 0, // 输出模式 GPIO_MODE_INPUT, // 输入模式 GPIO_MODE_INPUT_INT, // 中断模式 GPIO_MODE_MAX }GPIO_MODE; GPIO_LEVEL 高低电平 typedef enum{ GPIO_LEVEL_LOW = 0, //低电平 GPIO_LEVEL_HIGH = 1 //高电平 }GPIO_LEVEL; GPIO_INT_TYPE 中断类型 typedef enum { GPIO_INT_TYPE_HIGH_LEVEL = 0, //高电平中断 GPIO_INT_TYPE_LOW_LEVEL, //低电平中断 GPIO_INT_TYPE_RISING_EDGE, //上升沿中断 GPIO_INT_TYPE_FALLING_EDGE, //下降沿中断 GPIO_INT_TYPE_RISING_FALLING_EDGE, //上升沿和下降沿中断 GPIO_INT_TYPE_MAX }GPIO_INT_TYPE; 结构体类型 GPIO_INT_callback_param_t 中断回调函数参数类型 typedef struct{ GPIO_PIN pin; }GPIO_INT_callback_param_t; PCallbackINT 中断回调函数类型 typedef void (*PCallbackINT)(GPIO_INT_callback_param_t* param); GPIO_INT_config_t 中断配置选项 typedef struct{ uint16_t debounce; //去抖时间（ms） GPIO_INT_TYPE type ; PCallbackINT callback; }GPIO_INT_config_t; GPIO_config_t GPIO配置选项 typedef struct{ GPIO_PIN pin ; //引脚 GPIO_MODE mode ; //模式 GPIO_LEVEL defaultLevel; //默认电平 GPIO_INT_config_t intConfig ; //中断配置（中断模式需要配置） }GPIO_config_t; 功能函数接口 GPIO_Init bool GPIO_Init(GPIO_config_t config); 功能 初始化IO 参数 config：初始化配置 返回值 bool：配置成功/失败 GPIO_GetConfig void GPIO_GetConfig(GPIO_PIN pin,GPIO_config_t* config); 功能 获取GPIO配置 参数 config：GPIO配置变量地址 返回值 GPIO_SetLevel bool GPIO_SetLevel(GPIO_config_t gpioConf, GPIO_LEVEL level); 功能 设置GPIO电平 参数 gpioConf：GPIO初始化配置变量 level:电平高低 返回值 bool：是否设置成功 GPIO_Set bool GPIO_Set(GPIO_PIN pin, GPIO_LEVEL level); 功能 设置GPIO电平，与GPIO_SetLevel功能一样，只是参数不一样 参数 pin:GPIO口 level:电平高低 返回值 bool：是否设置成功 GPIO_GetLevel bool GPIO_GetLevel(GPIO_config_t gpioConf, GPIO_LEVEL* level); 功能 获取GPIO电平 参数 gpioConf:GPIO初始化配置变量 level:电平高低结果返回值，变量指针 返回值 bool：是否获取成功 GPIO_Get bool GPIO_Get(GPIO_PIN pin, GPIO_LEVEL* level); 功能 获取GPIO电平，功能与GPIO_GetLevel一样，只是参数不同 参数 pin:GPIO口 level:电平高低结果返回值，变量指针 返回值 bool：是否获取成功 GPIO_Close bool GPIO_Close(GPIO_PIN pin); 功能 关闭GPIO口，复位GPIO到默认状态 参数 pin:GPIO口 返回值 bool：是否成功 "},"c-sdk/gong-neng-ji-api/adc.html":{"url":"c-sdk/gong-neng-ji-api/adc.html","title":"ADC","keywords":"","body":"ADC（模数转换） A9/A9G模组有两个10位ADC接口，可以测量0~1.8V电压 例示程序参考 demo/adc 枚举类型 ADC_Channel_t ADC通道，总共两个通道，ADC0和ADC1 typedef enum { ADC_CHANNEL_0 = 0 , ADC_CHANNEL_1 , ADC_CHANNEL_MAX }ADC_Channel_t; ADC_Sample_Period_t ADC采样周期 typedef enum { ADC_SAMPLE_PERIOD_122US = 0 , ADC_SAMPLE_PERIOD_1MS , ADC_SAMPLE_PERIOD_10MS , ADC_SAMPLE_PERIOD_100MS , ADC_SAMPLE_PERIOD_250MS , ADC_SAMPLE_PERIOD_500MS , ADC_SAMPLE_PERIOD_1S , ADC_SAMPLE_PERIOD_2S , ADC_SAMPLE_PERIOD_MAX } ADC_Sample_Period_t;//Acquisition Time Period 结构体类型 ADC_Config_t ADC配置信息，包含了通道值和采样周期 typedef struct { ADC_Channel_t channel; ADC_Sample_Period_t samplePeriod; }ADC_Config_t; 功能函数 ADC_Init void ADC_Init(ADC_Config_t adcConfig); 功能 初始化ADC 参数 adcConfig：ADC配置信息 返回值 无 ADC_Read bool ADC_Read(ADC_Channel_t channel, uint16_t* value, uint16_t* mV); 功能 读取ADC值，包括数值（0~1023）和电压值(0~1.8v) 参数 channel:ADC通道选择 value:读取到的值，传入指针 mV:读取到的电压值，传入指针 返回值 bool：是否读取成功 ADC_Close void ADC_Close(ADC_Channel_t channel); 功能 关闭ADC定期采样，当所有通道关闭后会释放ADC硬件资源 参数 channel:ADC通道选择 返回值 无 "},"c-sdk/gong-neng-ji-api/uart.html":{"url":"c-sdk/gong-neng-ji-api/uart.html","title":"UART","keywords":"","body":"串口 模组共有三个UART，串口1、串口2以及下载调试串口HST串口 例程:demo/uart 枚举类型 UART_Port_t 串口编号 typedef enum{ UART1 = 1, UART2 = 2, UART_GPS = 2, UART_PORT_MAX }UART_Port_t; UART_Baud_Rate_t 波特率 typedef enum{ UART_BAUD_RATE_1200 = 1200, UART_BAUD_RATE_2400 = 2400, UART_BAUD_RATE_4800 = 4800, UART_BAUD_RATE_9600 = 9600, UART_BAUD_RATE_14400 = 14400, UART_BAUD_RATE_19200 = 19200, UART_BAUD_RATE_28800 = 28800, UART_BAUD_RATE_33600 = 33600, UART_BAUD_RATE_38400 = 38400, UART_BAUD_RATE_57600 = 57600, UART_BAUD_RATE_115200 = 115200, UART_BAUD_RATE_230400 = 230400, UART_BAUD_RATE_460800 = 460800, UART_BAUD_RATE_921600 = 921600, UART_BAUD_RATE_1300000 = 1300000, UART_BAUD_RATE_1625000 = 1625000, UART_BAUD_RATE_2166700 = 2166700, UART_BAUD_RATE_3250000 = 3250000, UART_BAUD_RATE_MAX = 3250001 }UART_Baud_Rate_t; UART_Data_Bits_t 数据位 typedef enum{ UART_DATA_BITS_7 = 7, UART_DATA_BITS_8 = 8, UART_DATA_BITS_MAX }UART_Data_Bits_t; UART_Stop_Bits_t 停止位 typedef enum{ UART_STOP_BITS_1 = 1, UART_STOP_BITS_2 , UART_STOP_BITS_MAX }UART_Stop_Bits_t; UART_Parity_t 校验位 typedef enum{ UART_PARITY_NONE = 0, UART_PARITY_ODD , UART_PARITY_EVEN , UART_PARITY_SPACE , UART_PARITY_MARK , UART_PARITY_MAX }UART_Parity_t; UART_Error_t 串口错误 typedef enum{ UART_ERROR_RX_LINE_ERROR, UART_ERROR_RX_OVER_FLOW_ERROR, UART_ERROR_RX_PARITY_ERROR, UART_ERROR_RX_BREAK_INT_ERROR, UART_ERROR_RX_FRAMING_ERROR, UART_ERROR_TX_OVER_FLOW_ERROR, UART_ERROR_MAX }UART_Error_t; 结构体类型 UART_Callback_Param_t 回调函数参数 typedef struct{ UART_Port_t port; uint32_t length; char *buf;//the receive buf }UART_Callback_Param_t; UART_Config_t 串口初始化参数 typedef struct{ UART_Baud_Rate_t baudRate; UART_Data_Bits_t dataBits; UART_Stop_Bits_t stopBits; UART_Parity_t parity; UART_Callback_t rxCallback; UART_Error_Callback_t errorCallback; bool useEvent; }UART_Config_t; 功能函数 UART_Callback_t typedef void (*UART_Callback_t)(UART_Callback_Param_t param); 功能 串口回调函数，由用户定义 参数 param：回调参数 返回值 无 UART_Error_Callback_t typedef void (*UART_Error_Callback_t)(UART_Error_t error); 功能 串口错误回调函数，由用户定义 参数 error：错误信息 返回值 无 UART_Init bool UART_Init(UART_Port_t uartN, UART_Config_t config); 功能 串口初始化 参数 uartN:串口号 config:串口配置 返回值 bool:是否初始化成功 UART_Write uint32_t UART_Write(UART_Port_t uartN, uint8_t* dataToWrite, uint32_t length); 功能 向串口写（发送）数据 参数 uartN:串口号 dataToWrite:需要写的数据 length:数据长度 返回值 成功写到串口的长度 UART_Read uint32_t UART_Read(UART_Port_t uartN, uint8_t* dataToRead, uint32_t length, uint32_t timeOutMs); 功能 从串口读取数据 参数 uartN:串口号 dataToWrite:读取的数据存放的位置 length:需要读取的数据长度 timeOutMs:超时时间，单位是毫秒 返回值 从串口成功读取到的数据长度 UART_Close bool UART_Close(UART_Port_t uartN); 功能 关闭串口 参数 uartN:串口 返回值 是否关闭成功 "},"c-sdk/gong-neng-ji-api/os.html":{"url":"c-sdk/gong-neng-ji-api/os.html","title":"OS","keywords":"","body":"操作系统(OS) 一个轻量级的操作系统，包含了基本的任务操作、消息机制等等 例程：demo/os 宏定义 OS_WAIT_FOREVER 超时时间特殊值，阻塞等待（永远等待） #define OS_WAIT_FOREVER 0xFFFFFFFF OS_NO_WAIT 超时时间特殊值，不等待 #define OS_NO_WAIT 0x0 OS_EVENT_PRI_NORMAL 事件优先级普通,OS_SendEvent的nOption参数的值 #define OS_EVENT_PRI_NORMAL 0 OS_EVENT_PRI_URGENT 事件优先级紧急，OS_SendEvent的nOption参数的值 #define OS_EVENT_PRI_URGENT 1 OS_CREATE_DEFAULT 函数OS_CreateTask的nCreationFlags参数的值，表示创建任务后自动开始执行任务 #define OS_CREATE_DEFAULT 0 OS_CREATE_SUSPENDED 函数OS_CreateTask的nCreationFlags参数的值，表示创建任务后不自动开始执行任务 #define OS_CREATE_SUSPENDED 1 结构体 OS_Heap_Status_t 堆状态，包括总大小和已经使用了的大小 typedef struct{ uint32_t usedSize; uint32_t totalSize; }OS_Heap_Status_t; 功能函数 PTASK_FUNC_T typedef void (*PTASK_FUNC_T)(PVOID pParameter); 功能 创建的任务主函数，由用户定义 参数 pParameter:调用这个函数的时候传入的参数 返回值 无 OS_SetUserMainHandle void OS_SetUserMainHandle(HANDLE* appMainHandle); 功能 设置主任务，主任务用来接收来自底层的消息，这个函数必须在开机的时候创建主任务后立即调用，否则可能导致底层无法向应用层发布消息 参数 appMainHandle:创建的主任务返回的指针（句柄） 返回值 无 OS_CreateTask HANDLE OS_CreateTask( PTASK_FUNC_T pTaskEntry, PVOID pParameter, PVOID pStackAddr, UINT16 nStackSize, UINT8 nPriority, UINT16 nCreationFlags, UINT16 nTimeSlice, PCSTR pTaskName); 功能 创建一个新的任务 参数 pTaskEntry:任务执行函数，PTASK_FUNC_T 类型 pParameter:需要传递给执行函数的参数 pStackAddr:自定义栈的地址，暂时不支持自定义，即值只能为NULL nStackSize:栈大小 nPriority:任务优先级，>=0，每个任务优先级不同，值越小任务优先级越大 nCreationFlags: OS_CREATE_DEFAULT/0：默认，创建任务后开始执行任务；OS_CREATE_SUSPENDED：创建任务后不执行任务，需要手动调用start函数开启任务运行 nTimeSlice:保留，值为0 pTaskName:任务名称 返回值 创建的任务的指针（句柄），如果创建任务失败，则返回NULL OS_StartTask void OS_StartTask( HANDLE pHTask, PVOID pParameter); 功能 开始执行任务 参数 pHTask:任务句柄，OS_CreateTask的返回值 pParameter:需要传给任务函数的参数 返回值 无 OS_StopTask void OS_StopTask( HANDLE pHTask); 功能 停止任务执行 参数 pHTask:任务句柄，OS_CreateTask的返回值 返回值 无 OS_DeleteTask bool OS_DeleteTask( HANDLE hTask); 功能 删除任务 参数 hTask:任务句柄，OS_CreateTask的返回值 返回值 删除任务是否成功 OS_SuspendTask bool OS_SuspendTask( HANDLE hTask); 功能 挂起线程 参数 hTask:任务句柄，OS_CreateTask的返回值 返回值 挂起是否成功 OS_ResumeTask bool OS_ResumeTask( HANDLE hTask); 功能 继续任务 参数 hTask:任务句柄，OS_CreateTask的返回值 返回值 是否成功 OS_Sleep bool OS_Sleep(UINT32 nMillisecondes); 功能 阻塞毫秒级延时 参数 nMillisecondes:阻塞延迟时间，单位毫秒 返回值 是否成功（始终为true） OS_SleepUs void OS_SleepUs(UINT32 us); 功能 阻塞微妙级延时 参数 us: 延时时间，单位微妙 返回值 无 OS_WaitEvent bool OS_WaitEvent( HANDLE hTask, PVOID* pEvent, UINT32 nTimeOut); 功能 阻塞等待事件 参数 hTask:任务句柄，OS_CreateTask的返回值 pEvent:事件值，来自OS_SendEvent的参数 nTimeOut:等待超时时间，目前只支持阻塞等待，即值必须为OS_WAIT_FOREVER 返回值 成功等待到事件 OS_SendEvent bool OS_SendEvent( HANDLE hTask, PVOID pEvent, UINT32 nTimeOut, UINT16 nOption); 功能 向某个任务发送事件 参数 hTask:任务句柄，OS_CreateTask的返回值 pEvent：事件发送的数据（指针） nTimeOut:超时时间，目前只支持阻塞等待，即值必须为OS_WAIT_FOREVER nOption:事件选项，OS_EVENT_PRI_NORMAL：普通优先级，OS_EVENT_PRI_URGENT:紧急优先级 返回值 事件是否发送成功 OS_ResetEventQueue bool OS_ResetEventQueue( HANDLE hTask); 功能 重置事件队列 参数 hTask:任务句柄，OS_CreateTask的返回值 返回值 是否重置成功 OS_IsEventAvailable bool OS_IsEventAvailable( HANDLE hTask); 功能 判断某个任务是否有事件可以接收 参数 hTask:任务句柄，OS_CreateTask的返回值 返回值 是否有事件可以接收 OS_Malloc PVOID OS_Malloc (UINT32 nSize); 功能 动态分配内存 参数 nSize:动态分配内存长度，单位是字节 返回值 动态分配内存块的首地址，若分配失败，则返回NULL OS_Realloc PVOID OS_Realloc(VOID *ptr, UINT32 nSize); 功能 重新分配内存 参数 ptr:动态分配的内存块首地址 nSize:新动态分配的内存块长度 返回值 成功分配的内存块首地址，若为NULL，则分配失败 OS_Free bool OS_Free (PVOID pMemBlock); 功能 释放动态分配的内存 参数 pMemBlock:动态分配的内存块首地址 返回值 是否释放成功 OS_GetHeapUsageStatus bool OS_GetHeapUsageStatus(OS_Heap_Status_t* pOsHeapStatus); 功能 获取堆的使用情况， 值得注意的是，如果是用OS_Malloc函数分配小的空间后（比如几个字节），使用此函数获得返回的剩余空间大小可能不会减少，而是保持不变。 这是因为内部为减少碎片而做的优化，即预先申请一块空间（331280字节），这块空间用来为以后申请小空间（ 实际上内部预先分配了331280字节来给未来分配给小空间， 调用OS_Malloc(n)时实际分配如下表，比如OS_Malloc(5)，因为5 簇编号 用户申请字节范围0～m(n 块数量 预分配实际占用的空间 1 10 250 （实际占用了 36*250 字节） 2 24 250 （实际占用了 48*250 字节） 3 28 250 （实际占用了 52*250 字节） 4 32 250 （实际占用了 56*250 字节） 5 52 250 （实际占用了 76*250 字节） 6 100 200 （实际占用了 124*200 字节） 7 156 200 （实际占用了 180*200 字节） 8 200 20 （实际占用了 224*20 字节） 9 528 200 （实际占用了 552*200 字节） 10 700 50 （实际占用了 724*50 字节） 11 1024 50 （实际占用了 1048*50 字节） 参数 pOsHeapStatus:堆使用情况 返回值 是否获取堆状态成功 OS_CreateSemaphore HANDLE OS_CreateSemaphore( UINT32 nInitCount // Specify the initial count of the semaphore ); 功能 创建一个信号量 参数 nInitCount:信号量初始化值，0表示资源被占用，n表示有n个资源值，每次wait将会等待资源值并减一，release操作将会将资源值加一 返回值 信号量句柄，如果失败，返回NULL OS_DeleteSemaphore bool OS_DeleteSemaphore( HANDLE hSem); 功能 删除信号量 参数 hSem:信号量句柄，OS_CreateSemaphore的返回值 返回值 信号量是否删除成功 OS_WaitForSemaphore bool OS_WaitForSemaphore( HANDLE hSem, // Specify the handle to a counting semaphore UINT32 nTimeOut // the time-out value ); 功能 等待信号量知道资源值大于0，并将资源值减一 参数 hSem:信号量句柄，OS_CreateSemaphore的返回值 nTimeOut:超时值，暂时保留，即值为OS_WAIT_FOREVER 返回值 是否成功获取到信号量（资源值） OS_ReleaseSemaphore bool OS_ReleaseSemaphore( HANDLE hSem //Specify the counting semaphore ); 功能 释放信号量，即资源值加一 参数 hSem:信号量句柄，OS_CreateSemaphore的返回值 返回值 是否释放信号量（资源值）成功 OS_CreateMutex HANDLE OS_CreateMutex(void); 功能 创建一个互斥量 参数 无 返回值 互斥量句柄，如果失败，返回NULL OS_DeleteMutex void OS_DeleteMutex(HANDLE mutex); 功能 删除互斥量 参数 mutex:互斥量句柄，OS_CreateMutex的返回值 返回值 无 OS_LockMutex void OS_LockMutex(HANDLE mutex); 功能 锁互斥量，即占用资源 参数 mutex:互斥量句柄，OS_CreateMutex的返回值 返回值 无 OS_UnlockMutex void OS_UnlockMutex(HANDLE mutex); 功能 释放互斥量，即释放资源 参数 mutex:互斥量句柄，OS_CreateMutex的返回值 返回值 无 OS_CALLBACK_FUNC_T typedef void (*OS_CALLBACK_FUNC_T)(void* param); 功能 回调函数，由用户定义 参数 param：用户传入的参数 返回值 无 OS_StartCallbackTimer bool OS_StartCallbackTimer(HANDLE hTask, UINT32 ms, OS_CALLBACK_FUNC_T callback, void* param); 功能 开始软件计时器，设定时间到了后会触发回调函数 参数 hTask:任务句柄，这个指定的任务里必须包含OS_WaitEvent函数调用（比如可以传主任务），否则不会触发回调 ms：定时时间 callback：回调函数 param：传入回调函数的参数 返回值 创建定时器是否成功 OS_StopCallbackTimer bool OS_StopCallbackTimer(HANDLE hTask, OS_CALLBACK_FUNC_T callback, void *param); 功能 停止软件计时器 参数 hTask:任务句柄，这个指定的任务里必须包含OS_WaitEvent函数调用（比如可以传主任务），否则不会触发回调 callback：回调函数 param：传入回调函数的参数 返回值 停止定时器是否成功 OS_QueryCallbackTimer uint32_t OS_QueryCallbackTimer(HANDLE hTask, OS_CALLBACK_FUNC_T callback, void *param); 功能 查询软件计时器还剩多少时间结束 参数 hTask:任务句柄，这个指定的任务里必须包含OS_WaitEvent函数调用（比如可以传主任务），否则不会触发回调 callback：回调函数 param：传入回调函数的参数 返回值 定时器离结束剩余的时间 "},"c-sdk/gong-neng-ji-api/imei.html":{"url":"c-sdk/gong-neng-ji-api/imei.html","title":"IMEI","keywords":"","body":"IMEI IMEI是一串长度为15个字节的字符串，每个模组对应唯一IMEI号，生产出厂的时候确定，并且印在模组壳子上，以二维码形式存在，可以用手机扫描得到二维码得到，也可以通过API函数得到 例程：demo/imei 函数 INFO_GetIMEI bool INFO_GetIMEI(uint8_t* pImei); 功能 获取模组IMEI号 参数 pImei:获取到的IMEI号存放位置，注意，数组长度>=15字节 返回值 是否获取IMEI号成功 "},"c-sdk/gong-neng-ji-api/ccid.html":{"url":"c-sdk/gong-neng-ji-api/ccid.html","title":"ICCID","keywords":"","body":"ICCID(Integrate circuit card identity 集成电路卡识别码) ICCD是SIM卡的唯一标识,长度为20的字符串。 例程：demo/iccid 函数 SIM_GetICCID bool SIM_GetICCID(uint8_t* iccid); 功能 获取SIM卡ICCID值 参数 iccid：获取到的iccid值存放位置，数组长度>=20 返回值 是否成功获取ICCID值，如果失败请检查卡是否插好 "},"c-sdk/gong-neng-ji-api/gps.html":{"url":"c-sdk/gong-neng-ji-api/gps.html","title":"GPS","keywords":"","body":"GPS 获取卫星定位信息，A9G模组内GPS芯片和GPRS芯片的串口2相连，故GPS启动后产生的信息会在串口2收到 例程：demo/gps 注意：在使用定位坐标显示到地图上时，注意坐标的转换，模组输出的位置是WGS84坐标，如果使用百度地图，需要转换成BD-09坐标，如果使用的腾讯地图、高德地图、google地图等，请先转换到GCJ-02坐标（火星坐标），否则显示结果可能会产生巨大误差 GPS输出的原始信息格式为NMEA标准，比如坐标(2236.3934,11350.3831)表示(22度36.3934分，113度50.3831分)，转换成度：(22.606557°，113.839718°)，此为WGS84坐标，然后复制到地图查看工具中即可看到在地图中的位置： 函数 GPS_Open bool GPS_Open(UART_Callback_t gpsReceivedCallback); 功能 开启GPS电源，GPS进入工作状态 参数 gpsReceivedCallback：串口回调函数，如果设置为NULL，则收到串口2收到GPS数据后不会产生回调，而是将GPS的数据以事件的方式发送给主任务；若不为NULL，则不会产生事件，设置的串口回调函数会被调用，不要在处理函数中消耗太多时间。建议使用事件的方式，参考GPS例程 返回值 是否成功打开GPS GPS_Close bool GPS_Close(); 功能 关闭GPS电源 参数 无 返回值 是否成功关闭GPS "},"c-sdk/gong-neng-ji-api/iic.html":{"url":"c-sdk/gong-neng-ji-api/iic.html","title":"I2C","keywords":"","body":"I2C A9/A9G有三个I2C接口，使用的时候注意与哪些引脚复用了的，引脚情况查看pudding开发板引脚图 只支持主模式 例程：demo/i2c 宏定义 I2C_DEFAULT_TIME_OUT 默认超时时间 #define I2C_DEFAULT_TIME_OUT 10 //10ms 枚举类型 I2C_ID_t I2C编号 typedef enum { I2C1 = 1 , I2C2 = 2 , I2C3 = 3 , I2C_ID_MAX } I2C_ID_t; I2C_FREQ_t I2C支持的频率 typedef enum { I2C_FREQ_100K, I2C_FREQ_400K, I2C_FREQ_MAX } I2C_FREQ_t; I2C_Error_t I2C错误信息 typedef enum{ I2C_ERROR_NONE = 0 , /// A resource reset is required I2C_ERROR_RESOURCE_RESET, /// An attempt to access a busy resource failed I2C_ERROR_RESOURCE_BUSY, /// Timeout while trying to access the resource I2C_ERROR_RESOURCE_TIMEOUT, /// An attempt to access a resource that is not enabled I2C_ERROR_RESOURCE_NOT_ENABLED, /// Invalid parameter I2C_ERROR_BAD_PARAMETER, /// Communication failure I2C_ERROR_COMMUNICATION_FAILED = 14, I2C_ERROR_MAX } I2C_Error_t; I2C_CMD_Mask_t I2C标志位，功能函数中带Raw的函数使用 typedef enum{ I2C_CMD_MASK_MASTER_NACK = (1 结构体类型 I2C_Config_t I2C配置 typedef struct{ I2C_FREQ_t freq; } I2C_Config_t; 功能函数 I2C_Init bool I2C_Init(I2C_ID_t i2c, I2C_Config_t config); 功能 初始化I2C 参数 i2c：I2C编号 config：I2C初始化配置 返回值 是否成功设置I2C I2C_Transmit I2C_Error_t I2C_Transmit(I2C_ID_t i2c, uint16_t slaveAddr, uint8_t* pData, uint16_t length, uint32_t timeOut); 功能 通过I2C发送数据 参数 i2c：I2C编号 slaveAddr:从机地址 pData:需要发送的数据 length：长度 timeOut:超时时间，单位毫秒 返回值 是否成功发送数据 I2C_Receive I2C_Error_t I2C_Receive(I2C_ID_t i2c, uint16_t slaveAddr, uint8_t* pData, uint16_t length, uint32_t timeOut); 功能 通过I2C接收数据 参数 i2c：I2C编号 slaveAddr:从机地址 pData:接收到的数据存放位置 length：长度 timeOut:超时时间，单位毫秒 返回值 是否成功接收数据 I2C_WriteMem I2C_Error_t I2C_WriteMem(I2C_ID_t i2c, uint16_t slaveAddr, uint32_t memAddr, uint8_t memSize, uint8_t* pData, uint16_t length, uint32_t timeOut); 功能 通过I2C写从器件寄存器 参数 i2c：I2C编号 slaveAddr:从机地址 memAddr：从机寄存器地址 memSize：从机寄存器地址长度，单位字节，即memAddr的字节数，最大为4 pData:要写的数据的数据 length：写数据长度 timeOut:超时时间，单位毫秒 返回值 是否成功写入数据 I2C_ReadMem I2C_Error_t I2C_ReadMem(I2C_ID_t i2c, uint16_t slaveAddr, uint32_t memAddr, uint8_t memSize, uint8_t* pData, uint16_t length, uint32_t timeOut); 功能 通过I2C读从器件寄存器 参数 i2c：I2C编号 slaveAddr:从机地址 memAddr：从机寄存器地址 memSize：从机寄存器地址长度，单位字节，即memAddr的字节数，最大为4 pData:读取的数据存放的位置 length：读取数据长度，单位字节 timeOut:超时时间，单位毫秒 返回值 是否成功读取从机寄存器数据 I2C_WriteRawByte I2C_Error_t I2C_WriteRawByte(I2C_ID_t i2c, uint8_t sendByte, I2C_CMD_Mask_t cmdMask, uint32_t timeOut); 功能 通过I2C写单个字节数据 参数 i2c：I2C编号 sendByte:需要发送的数据，一个字节 cmdMask：附加的命令，I2C_CMD_Mask_t中的值 timeOut:超时时间，单位毫秒 返回值 是否成功写入数据 I2C_ReadRawByte uint8_t I2C_ReadRawByte(I2C_ID_t i2c, I2C_CMD_Mask_t cmdMask, uint32_t timeOut); 功能 通过I2C读单个字节数据 参数 i2c：I2C编号 cmdMask：附加的命令，I2C_CMD_Mask_t中的值 timeOut:超时时间，单位毫秒 返回值 读取到的值 I2C_Close bool I2C_Close(I2C_ID_t i2c); 功能 关闭I2C 参数 i2c：I2C编号 返回值 是否成功关闭I2C "},"c-sdk/gong-neng-ji-api/spi.html":{"url":"c-sdk/gong-neng-ji-api/spi.html","title":"SPI","keywords":"","body":"SPI A9/A9G有两个SPI接口，使用的时候注意与哪些引脚复用了的，引脚情况查看pudding开发板引脚图 例程：demo/spi 宏定义 SPI_FREQ_MAX SPI最大支持频率 #define SPI_FREQ_MAX 13000000 枚举类型 SPI_ID_t SPI编号，共两个SPI typedef enum { SPI1 = 1 , SPI2 = 2 , } SPI_ID_t; SPI_CS_t SPI CS引脚，每个SPI都有两个CS引脚可供选择 typedef enum { SPI_CS_0 = 0 , SPI_CS_1 , SPI_CS_MAX } SPI_CS_t; SPI_Mode_t SPI模式，分为轮询、中断、DMA轮询、DMA中断四种模式 typedef enum { /// Direct polling: The application sends/receives the data directly to/from /// the hardware module. The number of bytes actually sent/received is /// returned. SPI_MODE_DIRECT_POLLING , /// Direct IRQ: The application sends/receives the data directly to/from /// the hardware module. The number of bytes actually sent/received is /// returned. An Irq can be generated when the Tx/Rx FIFO reaches the /// pre-programmed level. SPI_MODE_DIRECT_IRQ , /// DMA polling: The application sends/receives the data through a DMA to /// the hardware module. The function returns 0 when no DMA channel is /// available. No bytes are sent. The function returns the number of bytes /// to send when a DMA resource is available. They will all be sent. A /// function allows to check if the previous DMA transfer is finished. No /// new DMA transfer in the same direction will be allowed before the end /// of the previous transfer. SPI_MODE_DMA_POLLING , /// DMA IRQ: The application sends/receives the data through a DMA to the /// hardware module. The function returns 0 when no DMA channel is /// available. No bytes are sent. The function returns the number of bytes /// to send when a DMA resource is available. They will all be sent. An /// IRQ is generated when the current transfer is finished. No new DMA /// transfer in the same direction will be allowed before the end of the /// previous transfer. SPI_MODE_DMA_IRQ , SPI_MODE_MAX } SPI_Mode_t; SPI_Line_t SPI 支持3线和4线模式 typedef enum{ SPI_LINE_3 = 3 , /// Half-Duplex Mode SPI_LINE_4 = 4 , /// Full-Duplex Mode } SPI_Line_t; SPI_Data_Bits_t SPI 数据位 typedef enum{ SPI_DATA_BITS_8 = 8 , SPI_DATA_BITS_16 = 16, } SPI_Data_Bits_t; 结构体类型 SPI_Irq_Flags_t SPI中断标志 typedef struct { /// Rx FIFO overflow bool rxOverflow; /// Tx send finish bool txFinish; /// Tx DMA send finish bool txDmaDone; /// Rx send finish bool rxFinish; /// Rx DMA send finish bool rxDmaDone; } SPI_Irq_Flags_t; SPI_Config_t SPI配置 typedef struct { /// Select the Chip Select SPI_CS_t cs; /// Emission transfer mode SPI_Mode_t txMode; /// Reception transfer mode SPI_Mode_t rxMode; /// SPI clock frequency /// up to 13Mbits/s (SPI_FREQ_MAX) uint32_t freq; /// SPI transfer line mode SPI_Line_t line; /// SPI tx only /// false: tx only disable /// true: tx only enable bool txOnly; /// SPI Clk Polarity /// 0 when SPI is free,clk line is in low level /// 1 when SPI is free,clk line is in high level uint8_t cpol; /// SPI Clk Phase /// 0 SPI sampling data at the first edge /// 1 SPI sampling data at the second edge uint8_t cpha; /// SPI Cs Active Polarity /// true: Cs Active Low /// false: Cs Active High bool csActiveLow; /// SPI framesize SPI_Data_Bits_t dataBits; SPI_Irq_Handler_t irqHandler; SPI_Irq_Flags_t irqMask; } SPI_Config_t; 功能函数 SPI_Irq_Handler_t typedef void (*SPI_Irq_Handler_t)(SPI_Irq_Flags_t flags); 功能 SPI 中断回调函数 参数 flags:中断状态标志 返回值 无 SPI_Init bool SPI_Init(SPI_ID_t spiN, SPI_Config_t spiConfig); 功能 初始化SPI 参数 spiN:SPI编号 spiConfig：SPI配置 返回值 是否成功初始化 SPI_Close bool SPI_Close(SPI_ID_t spiN); 功能 关闭SPI 参数 spiN:SPI编号 返回值 是否成功关闭SPI SPI_Write uint32_t SPI_Write(SPI_ID_t spiN, const uint8_t *data, uint32_t length); 功能 向SPI写数据 参数 spiN:SPI编号 data：需要发送的数据 length：需要发送的数据的长度 返回值 成功发送的数据长度，如果在DMA模式下返回值为0，则表示DMA通道不可用 SPI_Read uint32_t SPI_Read(SPI_ID_t spiN, uint8_t *data, uint32_t length); 功能 从SPI读取数据 参数 spiN:SPI编号 data：读取的数据存放的位置 length：需要读取的数据的长度 返回值 读取到的数据长度，单位字节 SPI_IsTxDone bool SPI_IsTxDone(SPI_ID_t spiN); 功能 检查最后一次传输是否已经完成，如果传输的数据很重要，在关闭SPI前这个函数最好被调用。 在直接传输和DMA传输的过程中不应该被调用 参数 spiN:SPI编号 返回值 如果发送FIFO空，返回true；否则返回false SPI_IsTxDmaDone bool SPI_IsTxDmaDone(SPI_ID_t spiN); 功能 查询SPI DMA发送是否完成，在DMA模式发送新的数据时要保证之前的数据已经发送完成，可以用这个函数来轮询。 需要注意的是DMA发送完成了但是发送FIFO可能不为空，及时这样也可以进行下一次DMA新的数据发送，关闭SPI之前必须要用SPI_IsTxDone检查SPI FIFO是否为空 参数 spiN:SPI编号 返回值 DMA传输是否完成 SPI_IsRxDmaDone bool SPI_IsRxDmaDone(SPI_ID_t spiN); 功能 检查DMA接收数据是否完成 参数 spiN:SPI编号 返回值 是否成功接收数据完毕 SPI_ClearTxDmaDone void SPI_ClearTxDmaDone(SPI_ID_t spiN); 功能 清除SPI DMA发送完成标志 参数 spiN:SPI编号 返回值 无 SPI_FlushFIFOs void SPI_FlushFIFOs(SPI_ID_t spiN); 功能 刷新两个SPI的缓冲区（FIFO） 参数 spiN:SPI编号 返回值 无 SPI_SetIrqHandler void SPI_SetIrqHandler(SPI_ID_t spiN, SPI_Irq_Handler_t handler); 功能 设置中断回调函数 参数 spiN:SPI编号 handler：中断回调函数 返回值 无 SPI_SetIrqMask void SPI_SetIrqMask(SPI_ID_t spiN, SPI_Irq_Flags_t irqMask); 功能 设置中断标志位，即使能哪些中断标志位 参数 spiN:SPI编号 irqMask：中断标志 返回值 无 "},"c-sdk/gong-neng-ji-api/timertc.html":{"url":"c-sdk/gong-neng-ji-api/timertc.html","title":"time(RTC)","keywords":"","body":"time（RTC） 基本的RTC时间以及系统时间戳，以及网络时间同步等 例程：demo/time 时间相关类型 time_t 用整数来表示时间 typedef int32_t time_t; clock_t 用整数来表示时间 typedef long clock_t; 宏定义 CLOCKS_PER_SEC 系统clock转秒 #define CLOCKS_PER_SEC (16384.0) CLOCKS_PER_MSEC 系统clock转ms #define CLOCKS_PER_MSEC (16.384) 结构体类型 tm 时间表示，包括年月日时分秒 typedef struct tm{ int tm_sec; /* 秒，范围从 0 到 59 */ int tm_min; /* 分，范围从 0 到 59 */ int tm_hour; /* 小时，范围从 0 到 23 */ int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ int tm_mon; /* 月，范围从 0 到 11 */ int tm_year; /* 自 1900 年起的年数 */ int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ int tm_isdst; /* 夏令时 */ }tm; timeval_t 时间，秒和微秒表示 typedef struct timeval { time_t tv_sec; // seconds long tv_usec; //microsecond }timeval_t; timezone_t 时区类型 typedef struct timezone { int tz_minuteswest; int tz_dsttime; }timezone_t; RTC_Time_t RTC时间 typedef struct{ uint16_t year; uint8_t month; uint8_t day; uint8_t hour; uint8_t minute; uint8_t second; int8_t timeZone; // 时区小时数 int8_t timeZoneMinutes; // 时区不足小时的分钟数 // 所以 `时区 = timeZone+timeZoneMinutes/60` }RTC_Time_t; 功能函数 gettimeofday int gettimeofday(timeval_t *tv, timezone_t *tz); 功能 获取系统时间，秒和微秒 参数 tv：时间信息，秒和微妙(实际上系统无法到微妙级,值是毫秒*1000得到) tz：未实现，始终为NULL 返回值 获取成功返回0，否则非0 TIME_SetIsAutoUpdateRtcTime void TIME_SetIsAutoUpdateRtcTime(bool isAutoUpdate); 功能 附着到GPRS网络时，会获取到网络时间，如果设置为true，则将这个网络时间同步到RTC本地时间， 设置为false则不会同步 参数 isAutoUpdate：是否同步网络时间 返回值 无 TIME_IsAutoUpdateRtcTime bool TIME_IsAutoUpdateRtcTime(); 功能 查询当前配置，是否会自动从网路同步时间到本地时间 参数 无 返回值 是否自动同步网络时间到本地，true：同步； false：不同步 TIME_SetRtcTime bool TIME_SetRtcTime(RTC_Time_t* time); 功能 设置本地RTC时间 参数 time:时间 返回值 是否设备成功 TIME_GetRtcTIme bool TIME_GetRtcTIme(RTC_Time_t* time); 功能 获取本地RTC时间 参数 time：时间 返回值 是否成功获取到时间 clock clock_t clock(void); 功能 获取系统时钟，注意不是时间，需要转换，比如转换成秒需要除以16384，运算时注意是整数运算还是浮点运算 参数 无 返回值 系统时钟 "},"c-sdk/gong-neng-ji-api/fswen-jian-xi-7edf2928-chu-cun-shu-ju-dao-flash-huo-t-536129.html":{"url":"c-sdk/gong-neng-ji-api/fswen-jian-xi-7edf2928-chu-cun-shu-ju-dao-flash-huo-t-536129.html","title":"FS(文件系统)(储存数据到flash或T卡)","keywords":"","body":"File System 为了操作Flash更加简单，内置了文件系统和常用的API， 需要持久化数据或者配置信息，只需要将其保存为文件即可， 如果没有接触过文件系统， 可以简单地理解为， 当我们需要把数据储存到flash，每次储存我们自己擦除flash然后再写入，写到哪里怎么写这些策略需要我们自己安排， 而文件系统就是帮我们解决这个策略的问题，我们只需要调用api把数据发送给文件系统，文件系统自己会决定擦除哪个分区以及储存到哪个分区 需要注意的是文件系统是在Flash上的，不需要TF卡都可以使用，总大小有408k，当然可使用的空间小于408k，如果使用OTA还要给固件存放预留最大64k的空间。 当然也可以保存到外部TF卡，开机默认挂在TF卡到/t位置了，最大支持16G储存空间的TF卡 例程：demo/fs 宏定义 FS_TFLASH_ROOT TF卡开机自动挂载的位置 #define FS_TFLASH_ROOT \"/t\" FS_O_RDONLY 只读 #define FS_O_RDONLY 0 FS_O_WRONLY 只写 #define FS_O_WRONLY 1 FS_O_RDWR 读写 #define FS_O_RDWR 2 FS_O_ACCMODE 读写文件操作时，用于取出flag的低2位（判断文件权限） #define FS_O_ACCMODE 3 FS_O_CREAT 如果文件存在，不产生影响，不存在则建立，返回成功 如果文件存在且有FS_O_EXCL，则返回失败 #define FS_O_CREAT 00100 FS_O_EXCL 如果它和FS_O_CREAT同时设定，且文件已经存在，则创建文件操作会失败，返回-1 #define FS_O_EXCL 00200 FS_O_TRUNC 如果文件存在，则以只写或只读打开，并删除文件之前的内容 #define FS_O_TRUNC 01000 FS_O_APPEND 追加 #define FS_O_APPEND 02000 FS_ATTR_MARK 文件属性标记 #define FS_ATTR_MARK 0x0 FS_ATTR_RO 文件属性只读 #define FS_ATTR_RO 0x00000001 FS_ATTR_HIDDEN 文件属性隐藏 #define FS_ATTR_HIDDEN 0x00000002 FS_ATTR_SYSTEM 文件属性系统文件 #define FS_ATTR_SYSTEM 0x00000004 FS_ATTR_VOLUME 卷标 #define FS_ATTR_VOLUME 0x00000008 FS_ATTR_DIR 文件夹 #define FS_ATTR_DIR 0x00000010 FS_ATTR_ARCHIVE 压缩文件 #define FS_ATTR_ARCHIVE 0x00000020 FS_SEEK_SET 文件开头 #define FS_SEEK_SET 0 FS_SEEK_CUR 当前位置 #define FS_SEEK_CUR 1 FS_SEEK_END 末尾位置 #define FS_SEEK_END 2 FS_DEVICE_NAME_T_FLASH TF卡名称 #define FS_DEVICE_NAME_T_FLASH \"TF\" FS_DEVICE_NAME_FLASH Flash名称 #define FS_DEVICE_NAME_FLASH \"FLASH\" ERR_FS 错误信息,错误信息详细信息请看api_inc_fs.h #define ERR_FS_IS_DIRECTORY -4200001 #define ERR_FS_NOT_DIRECTORY -4200002 #define ERR_FS_NO_DIR_ENTRY -4200003 #define ERR_FS_OPERATION_NOT_GRANTED -4200005 #define ERR_FS_DIR_NOT_EMPTY -4200006 #define ERR_FS_FDS_MAX -4200007 #define ERR_FS_PROCESS_FILE_MAX -4200008 #define ERR_FS_FILE_EXIST -4200009 #define ERR_FS_NO_BASENAME -4200011 #define ERR_FS_BAD_FD -4200012 #define ERR_FS_NO_MORE_FILES -4200013 #define ERR_FS_HAS_MOUNTED -4200014 #define ERR_FS_MOUNTED_FS_MAX -4200015 #define ERR_FS_UNKNOWN_FILESYSTEM -4200016 #define ERR_FS_INVALID_DIR_ENTRY -4200018 #define ERR_FS_INVALID_PARAMETER -4200019 #define ERR_FS_NOT_SUPPORT -4200020 #define ERR_FS_UNMOUNT_FAILED -4200021 #define ERR_FS_NO_MORE_MEMORY -4200025 #define ERR_FS_DEVICE_NOT_REGISTER -4200027 #define ERR_FS_DISK_FULL -4200030 #define ERR_FS_NOT_FORMAT -4200032 #define ERR_FS_HAS_FORMATED -4200033 #define ERR_FS_NOT_FIND_SB -4200035 #define ERR_FS_DEVICE_BUSY -4200037 #define ERR_FS_OPEN_DEV_FAILED -4200038 #define ERR_FS_ROOT_FULL -4200039 #define ERR_FS_ACCESS_REG_FAILED -4200040 #define ERR_FS_PATHNAME_PARSE_FAILED -4200041 #define ERR_FS_READ_DIR_FAILED -4200048 #define ERR_FS_MOUNT_READ_ROOT_INODE_FAILED -4200050 #define ERR_FS_INVALID_DEV_NUMBER -4200051 #define ERR_FS_RENAME_DIFF_PATH -4200052 #define ERR_FS_FORMAT_MOUNTING_DEVICE -4200053 #define ERR_FS_DATA_DESTROY -4200056 #define ERR_FS_READ_SECTOR_FAILED -4200057 #define ERR_FS_WRITE_SECTOR_FAILED -4200058 #define ERR_FS_READ_FILE_EXCEED -4200059 #define ERR_FS_WRITE_FILE_EXCEED -4200060 #define ERR_FS_FILE_TOO_MORE -4200061 #define ERR_FS_FILE_NOT_EXIST -4200062 #define ERR_FS_DEVICE_DIFF -4200063 #define ERR_FS_GET_DEV_INFO_FAILED -4200064 #define ERR_FS_NO_MORE_SB_ITEM -4200065 #define ERR_FS_NOT_MOUNT -4200066 #define ERR_FS_NAME_BUFFER_TOO_SHORT -4200068 #define ERR_FS_NOT_REGULAR -42000100 #define ERR_FS_VOLLAB_IS_NULL -42000101 结构体类型 API_FS_INFO 文件系统空间信息，包括总空间和已经使用的空间信息 typedef struct { UINT64 totalSize; // Total size UINT64 usedSize; // Has used size } API_FS_INFO; 功能函数 API_FS_Open int32_t API_FS_Open( PCSTR fileName, uint32_t operationFlag, uint32_t mode ); 功能 打开文件 参数 fileName：文件名，注意文件名只接受unicode编码, 先调用LocalLanguage2UnicodeBigEndian将字符格式转换为unicode编码 operationFlag：操作标记，比如只读、只写等(FS_O_...)，可以多个操作进行或运算传入 mode：模式,文件或文件夹属性，FS_ATTR_...，可以多个操作进行或运算传入 返回值 如果成功返回大于等于零的文件描述符，负责返回错误代码 API_FS_Close int32_t API_FS_Close( int32_t fd ); 功能 关闭文件 参数 fd：文件描述符，API_FS_Open的返回值 返回值 成功返回0，否则返回错误代码 API_FS_Read int32_t API_FS_Read( int32_t fd, uint8_t* pBuffer, uint32_t length ); 功能 读取数据 参数 fd：文件描述符，API_FS_Open的返回值 pBuffer:读取到的数据存放的位置 length:读取数据的长度 返回值 成功读取到的数据字节，错误则返回错误代码（负数） API_FS_Write int32_t API_FS_Write( int32_t fd, uint8_t* pBuffer, uint32_t length ); 功能 写入文件 参数 fd：文件描述符，API_FS_Open的返回值 pBuffer:读取到的数据存放的位置 length:读取数据的长度 返回值 成功写入的数据字节，错误则返回错误代码（负数） API_FS_Flush uint32_t API_FS_Flush( int32_t fd ); 功能 刷新缓冲区 参数 fd：文件描述符，API_FS_Open的返回值 返回值 返回0或错误代码 API_FS_Create int32_t API_FS_Create( PCSTR fileName, uint32_t mode ); 功能 创建文件 参数 fileName:文件名，unicode编码 mode：文件属性FS_ATTR_...，可以多个属性或运算传入 返回值 成功返回0，否则返回错误代码 API_FS_Delete int32_t API_FS_Delete( PCSTR fileName ); 功能 删除文件 参数 fileName:文件名，unicode编码 返回值 成功返回0，否则返回错误代码 API_FS_Seek int64_t API_FS_Seek( int32_t fd, int64_t offset, uint8_t origin ); 功能 设置文件指针位置 参数 fd：文件描述符，API_FS_Open的返回值 offset：偏移，相对于origin的偏移字节数 origin：偏移的起始地址,具体位置或者特殊值：FS_SEEK_... 返回值 成功返回0，否则返回错误代码 API_FS_IsEndOfFile int32_t API_FS_IsEndOfFile( int32_t fd ); 功能 判断文件指针是否在文件末尾 参数 fd：文件描述符，API_FS_Open的返回值 返回值 是在末尾则返回1，没在末尾返回0，否则返回错误代码 API_FS_Rename int32_t API_FS_Rename( PCSTR oldName, PCSTR newName ); 功能 重命名文件 参数 oldName:旧文件名，unicode编码 newName:新文件名，unicode编码 返回值 成功返回0，否则返回错误代码 API_FS_GetFileName int32_t API_FS_GetFileName( int32_t fd, int32_t nameBufferLen, uint8_t* fileName ); 功能 根据文件描述符获取文件名 参数 fd：文件描述符，API_FS_Open的返回值 nameBufferLen：读取到的名字存放数组的长度 fileName：读取到的文件名 返回值 成功返回0，否则返回错误代码 API_FS_GetFileSize int64_t API_FS_GetFileSize( int32_t fd ); 功能 获取文件大小 参数 fd：文件描述符，API_FS_Open的返回值 返回值 文件大小，或者错误代码 API_FS_GetDirSize int64_t API_FS_GetDirSize( PCSTR fileName, uint64_t* size ); 功能 获取文件夹大小 参数 fileName：文件名，unicode编码 size：获取到的文件夹大小 返回值 成功返回0，否则返回错误代码 API_FS_GetCurDir int32_t API_FS_GetCurDir( uint32_t size, PSTR pCurDir ); 功能 获取当前文件夹名称 参数 size：得到的文件夹名称存放数组长度 pCurDir：得到的文件夹名称存放数组 返回值 成功返回0，否则返回错误代码 API_FS_ChangeDir int32_t API_FS_ChangeDir( PCSTR pDirName ); 功能 切换当前文件夹 参数 pDirName：文件夹名，unicode编码 返回值 成功返回0，否则返回错误代码 API_FS_Mkdir int32_t API_FS_Mkdir( PCSTR fileName, uint32_t mode ); 功能 创建文件夹 参数 fileName：文件名，unicode编码 mode：文件夹属性，FS_ATTR_... 返回值 成功返回0，否则返回错误代码 API_FS_Rmdir int32_t API_FS_Rmdir( PCSTR dirName ); 功能 删除文件夹 参数 dirName：文件夹名，unicode编码 返回值 成功返回0，否则返回错误代码 API_FS_GetFSInfo int32_t API_FS_GetFSInfo( PCSTR pDevName, API_FS_INFO* pFsInfo ); 功能 获取储存空间大小信息 参数 pDevName:设备名：FS_DEVICE_NAME_... pFsInfo:返回的储存空间信息 返回值 成功返回0，否则返回错误代码 "},"c-sdk/gong-neng-ji-api/gprswang-7edc28-ji-7ad929.html":{"url":"c-sdk/gong-neng-ji-api/gprswang-7edc28-ji-7ad929.html","title":"GPRS网络(基站信息等)","keywords":"","body":"GPRS相关及基站信息获取 模组上电后会自动注册GSM网络，注册成功后便可以通话、发送短信， 要实现上网功能则还需要激活GPRS网络，GPRS的基本知识在本文基础知识部分已经阐述了，这里边不再进行说明。 我们知道激活GPRS网络需要进行附着和上下文激活两个步骤， 而且这两个步骤有先后顺序，先进行附着再进行上下文激活。 网络相关的事件及参数可以在api_event.h中找到 例程：demo/network 宏定义 PDP_APN_MAX_LENGTH APN最长长度 #define PDP_APN_MAX_LENGTH 64 PDP_USER_NAME_MAX_LENGTH PDP用户名最长长度 #define PDP_USER_NAME_MAX_LENGTH 64 PDP_USER_PASSWD_MAX_LENGTH PDP用户密码最长长度 #define PDP_USER_PASSWD_MAX_LENGTH 64 结构体类型 Network_Status_t 网络状态 typedef enum{ NETWORK_STATUS_OFFLINE = 0 , NETWORK_STATUS_REGISTERING , NETWORK_STATUS_REGISTERED , NETWORK_STATUS_DETACHED , NETWORK_STATUS_ATTACHING , NETWORK_STATUS_ATTACHED , NETWORK_STATUS_DEACTIVED , NETWORK_STATUS_ACTIVATING , NETWORK_STATUS_ACTIVATED , NETWORK_STATUS_ATTACH_FAILED , NETWORK_STATUS_ACTIVATE_FAILED , NETWORK_STATUS_MAX }Network_Status_t; Network_PDP_Context_t PDP上下文参数设置 typedef struct{ char apn[PDP_APN_MAX_LENGTH]; // Access Point Name char userName[PDP_USER_NAME_MAX_LENGTH]; char userPasswd[PDP_USER_PASSWD_MAX_LENGTH]; }Network_PDP_Context_t; Network_Location_t 基站信息 typedef struct { uint8_t sMcc[3]; //移动国家号码，中国为460 uint8_t sMnc[3]; //移动网号，中国移动00，中国联通01 uint16_t sLac; //位置区号码 uint16_t sCellID; //小区识别码 uint8_t iBsic; //基站识别码 int8_t iRxLev; //接收报告信号强度 uint8_t iRxLevSub; //接收报告信号强度小数部分 uint16_t nArfcn; //基站频点 } Network_Location_t; Network_Error_t 网络错误信息 typedef enum{ NETWORK_ERROR_NONE = 0 , NETWORK_ERROR_MAX } Network_Error_t; 功能函数 Network_Callback_Func_t typedef void (*Network_Callback_Func_t)(Network_Status_t status); 功能 网络回调函数，由用户定义 参数 status：网络状态 返回值 无 Network_SetStatusChangedCallback void Network_SetStatusChangedCallback(Network_Callback_Func_t callback); 功能 设置网络回调函数,除了使用回调函数，也可以在主任务接收来自底层的事件（建议） 参数 callback:网路状态回调函数 返回值 无 Network_StartAttach bool Network_StartAttach(); 功能 开始附着网络 参数 无 返回值 true：成功执行附着网络，附着成功后会产生事件，false：附着失败，可能是已经附着或者无法附着 Network_StartDetach bool Network_StartDetach(); 功能 去附着网络 参数 无 返回值 true：执行去附着成功，false：执行去附着失败 Network_StartActive bool Network_StartActive(Network_PDP_Context_t context); 功能 开始上下文激活 参数 context：上下文设置，根据不同的运营商和网络设置 返回值 执行激活是否成功，如果失败，请检查信号以及是否已经附着了网络 Network_StartDeactive bool Network_StartDeactive(uint8_t contextID); 功能 上下文去激活 参数 contextID：上下文ID，这里作保留，目前传入值始终为1 返回值 去激活是否成功执行，具体是否成功会产生事件 Network_GetIp bool Network_GetIp(char* ip, uint8_t size); 功能 获得GPRS ip地址，注意这里的ip地址不是公网地址，而是局域网地址 参数 ip：获取到的ip地址点分十进制表示 size：字符串长度 返回值 是否成功获取ip地址 Network_GetCellInfoRequst bool Network_GetCellInfoRequst(); 功能 发起获取附近基站信息请求，信息会以事件（API_EVENT_ID_NETWORK_CELL_INFO）产生 参数 无 返回值 发起获取基站信息请求是否成功 "},"c-sdk/gong-neng-ji-api/dns.html":{"url":"c-sdk/gong-neng-ji-api/dns.html","title":"DNS","keywords":"","body":"DNS 域名解析服务，需要GPRS网络已经能正常使用的前提下使用 例程：demo/dns 枚举类型 DNS_Status_t DNS状态 typedef enum{ DNS_STATUS_ERROR = -1, DNS_STATUS_OK = 0, DNS_STATUS_WAIT = 1, DNS_STATUS_MAX }DNS_Status_t; 功能函数 DNS_CALLBACK_FUNC_T typedef VOID (*DNS_CALLBACK_FUNC_T)(DNS_Status_t status, void* param); 功能 DNS解析回调函数 参数 status:DNS状态 param：调用解析时传的参数 返回值 无 DNS_GetHostByName DNS_Status_t DNS_GetHostByName(const char* domain, char* ip); 功能 解析域名到IP地址，因为域名解析有时候时间很长，为了不阻塞程序，所以返回值有可能是DNS_STATUS_WAIT， 及域名解析还未完成，完成后会产生事件 参数 domain：域名 ip：解析到的ip地址存放的位置，请保证输出长度足够IP地址的点分十进制表示的长度 返回值 DNS_STATUS_OK：成功，DNS_STATUS_ERROR：错误，DNS_STATUS_WAIT：仍在解析，解析完成后会产生事件 DNS_GetHostByNameEX DNS_Status_t DNS_GetHostByNameEX(const char *hostname, char* ip, DNS_CALLBACK_FUNC_T func, void* param); 功能 解析域名到IP地址，成功后调用回调函数 参数 hostname：域名 ip：解析到的ip，请保证输出长度足够IP地址的点分十进制表示的长度，若返回DNS_STATUS_OK则有效，其它无效 fuc:回调函数 param:需要传给回调函数的参数 返回值 DNS_STATUS_OK：成功，DNS_STATUS_ERROR：错误，DNS_STATUS_WAIT：仍在解析，解析完成后会产生回调 DNS_GetHostByName2 int32_t DNS_GetHostByName2(const char* domain, char* ip); 功能 阻塞式解析域名到IP地址，使用简单，但是性能不佳 参数 hostname：域名 ip：解析到的ip，请保证输出长度足够IP地址的点分十进制表示的长度 返回值 0：成功 其它：错误代码 "},"c-sdk/gong-neng-ji-api/socketwang-luo-tong-xin.html":{"url":"c-sdk/gong-neng-ji-api/socketwang-luo-tong-xin.html","title":"socket网络通信","keywords":"","body":"Socket 网络通信，需要GPRS网络已经能正常使用的前提下使用 例程：demo/socket 枚举类型 TCP_UDP_t TCP、UDP选择 typedef enum{ TCP = 0, UDP =1 }TCP_UDP_t; API_Socket_Error_t 错误信息 typedef enum{ /** No error, everything OK. */ API_SOCKET_ERROR_NONE = 0, /** Out of memory error. */ API_SOCKET_ERROR_MEM = -1, /** Buffer error. */ API_SOCKET_ERROR_BUF = -2, /** Timeout. */ API_SOCKET_ERROR_TIMEOUT = -3, /** Routing problem. */ API_SOCKET_ERROR_RTE = -4, /** Operation in progress */ API_SOCKET_ERROR_INPROGRESS = -5, /** Illegal value. */ API_SOCKET_ERROR_VAL = -6, /** Operation would block. */ API_SOCKET_ERROR_WOULDBLOCK = -7, /** Address in use. */ API_SOCKET_ERROR_USE = -8, /** Already connecting. */ API_SOCKET_ERROR_ALREADY = -9, /** Conn already established.*/ API_SOCKET_ERROR_ISCONN = -10, /** Not connected. */ API_SOCKET_ERROR_CONN = -11, /** Low-level netif error */ API_SOCKET_ERROR_IF = -12, /** Connection aborted. */ API_SOCKET_ERROR_ABRT = -13, /** Connection reset. */ API_SOCKET_ERROR_RST = -14, /** Connection closed. */ API_SOCKET_ERROR_CLSD = -15, /** Illegal argument. */ API_SOCKET_ERROR_ARG = -16 }API_Socket_Error_t; 功能函数 Socket_TcpipConnect int Socket_TcpipConnect(TCP_UDP_t tcpOrUdp, const char* ip,uint16_t port); 功能 连接服务器 参数 tcpOrUdp:选择TCP协议还是UDP ip：要连接的ip地址 port：要连接的服务器端口 返回值 若成功，返回文件描述符fd，若失败，返回错误信息API_Socket_Error_t Socket_TcpipWrite int Socket_TcpipWrite(int socketFd, uint8_t* data, uint16_t length); 功能 向服务器发送数据 参数 socketFd:建立的socket连接文件描述符，Socket_TcpipConnect成功后的返回值 data：需要发送的数据 length：需要发送的数据的长度 返回值 成功发送的数据长度或者错误代码 Socket_TcpipRead int Socket_TcpipRead( int socketFd, uint8_t* data, uint16_t length); 功能 连接建立后，收到来自服务器的信息会产生事件，在事件触发后调用read函数即可读取数据 参数 socketFd:建立的socket连接文件描述符，Socket_TcpipConnect成功后的返回值 data：接收到的数据存放的位置 length：需要发送的数据的长度 返回值 读取到的数据的长度或者错误代码 Socket_TcpipClose bool Socket_TcpipClose(int socketFd); 功能 关闭socket连接 参数 socketFd:建立的socket连接文件描述符，Socket_TcpipConnect成功后的返回值 返回值 是否成功关闭socket连接 "},"c-sdk/gong-neng-ji-api/ssltls.html":{"url":"c-sdk/gong-neng-ji-api/ssltls.html","title":"SSL/TLS","keywords":"","body":"SSL/TLS 如果对SSL/TLS不是很熟悉，觉得各种证书很混乱，可以参照这篇文章生成证书 例程：demo/ssl 枚举类型 SSL_Version_t SSL/TLS版本 typedef enum{ SSL_VERSION_SSLv3 = 0, SSL_VERSION_TLSv1 , SSL_VERSION_TLSv1_1 , SSL_VERSION_TLSv1_2 , SSL_VERSION_MAX }SSL_Version_t; SSL_Error_t 错误信息 typedef enum{ SSL_ERROR_NONE = 0x00 , SSL_ERROR_PARAM = -0x01 , SSL_ERROR_PARSE = -0x02 , SSL_ERROR_MALLOC_FAIL= -3 , SSL_ERROR_CONNECTION = -4 , SSL_ERROR_TIMEOUT = -5 , SSL_ERROR_FAIL = -6 , SSL_ERROR_INTERNAL , SSL_ERROR_MAX } SSL_Error_t; SSL_Verify_Mode_t 验证模式 typedef enum{ SSL_VERIFY_MODE_NONE = 0, SSL_VERIFY_MODE_OPTIONAL = 1, SSL_VERIFY_MODE_REQUIRED = 2, SSL_VERIFY_MODE_MAX }SSL_Verify_Mode_t; 结构体类型 SSL_Config_t SSL/TLS配置 typedef struct{ const char* caCert; const char* caCrl; const char* clientCert; const char* clientKey; const char* clientKeyPasswd; const char* hostName; SSL_Version_t minVersion; SSL_Version_t maxVersion; SSL_Verify_Mode_t verifyMode; const char* entropyCustom; //自定义混淆字符 ////////////////////////////////// void* obj;//do not edit it ////////////////////////////////// } SSL_Config_t; 功能函数 SSL_Init SSL_Error_t SSL_Init(SSL_Config_t* sslConfig); 功能 初始化SSL/TLS 参数 sslConfig:初始化配置参数 返回值 返回错误信息 SSL_Connect SSL_Error_t SSL_Connect(SSL_Config_t* sslConfig, const char* server, const char* port); 功能 用SSL/TLS协议连接服务器 参数 sslConfig:SSL/TLS配置信息 server:需要连接的SSL/TLS服务器 port：服务器端口 返回值 返回错误信息 SSL_Write int SSL_Write(SSL_Config_t* sslConfig, uint8_t* data, int length, int timeoutMs); 功能 SSL/TLS发送数据（阻塞） 参数 sslConfig:SSL/TLS配置 data:发送给服务器的数据 length:发送给服务器的数据的长度 timeoutMs:发送超时时间（保留，暂不可用） 返回值 成功发送的数据长度或错误代码 SSL_Read int SSL_Read(SSL_Config_t* sslConfig, uint8_t* data, int length, int timeoutMs); 功能 读取数据 参数 sslConfig:SSL/TLS配置 data:接收到的数据 length:接收到的数据的长度 timeoutMs:接收超时时间 返回值 成功接收的数据长度或者错误代码 SSL_Close SSL_Error_t SSL_Close(SSL_Config_t* sslConfig); 功能 关闭连接 参数 sslConfig:SSL/TLS配置 返回值 关闭错误信息 SSL_Destroy SSL_Error_t SSL_Destroy(SSL_Config_t* sslConfig); 功能 释放SSL/TLS占用的空间 参数 sslConfig:SSL/TLS配置 返回值 释放错误信息 "},"c-sdk/gong-neng-ji-api/mqtt.html":{"url":"c-sdk/gong-neng-ji-api/mqtt.html","title":"MQTT","keywords":"","body":"MQTT MQTT是一种基于订阅发布模型的协议，在实时聊天（IM）、物联网等领域中有广泛应用 例程： demo/mqtt demo/mqtt_ssl 注意： MQTT相关的连接、断开连接、（取消）订阅发布等函数只能在线程中调用，不能在中断回调函数中调用，否则无法使用,参见例程的用法 枚举类型 MQTT_Error_t MQTT错误信息 typedef enum{ MQTT_ERROR_NONE = 0, //no error /** Out of memory error. */ MQTT_ERROR_MEM = -1, /** Buffer error. */ MQTT_ERROR_BUF = -2, /** Timeout. */ MQTT_ERROR_TIMEOUT = -3, /** Routing problem. */ MQTT_ERROR_RTE = -4, /** Operation in progress */ MQTT_ERROR_INPROGRESS = -5, /** Illegal value. */ MQTT_ERROR_VAL = -6, /** Operation would block. */ MQTT_ERROR_WOULDBLOCK = -7, /** Address in use. */ MQTT_ERROR_USE = -8, /** Already connecting. */ MQTT_ERROR_ALREADY = -9, /** Conn already established.*/ MQTT_ERROR_ISCONN = -10, /** Not connected. */ MQTT_ERROR_CONN = -11, /** Low-level netif error */ MQTT_ERROR_IF = -12, /** Connection aborted. */ MQTT_ERROR_ABRT = -13, /** Connection reset. */ MQTT_ERROR_RST = -14, /** Connection closed. */ MQTT_ERROR_CLSD = -15, /** Illegal argument. */ MQTT_ERROR_ARG = -16, MQTT_ERROR_PARAM = -17, MQTT_ERROR_DNS = -18 }MQTT_Error_t; MQTT_SSL_Version_t MQTT SSL支持的版本 typedef enum{ MQTT_SSL_VERSION_SSLv3 = 0, MQTT_SSL_VERSION_TLSv1 , MQTT_SSL_VERSION_TLSv1_1 , MQTT_SSL_VERSION_TLSv1_2 , MQTT_SSL_VERSION_MAX }MQTT_SSL_Version_t; MQTT_SSL_Verify_Mode_t 验证模式 typedef enum{ MQTT_SSL_VERIFY_MODE_NONE = 0, MQTT_SSL_VERIFY_MODE_OPTIONAL = 1, MQTT_SSL_VERIFY_MODE_REQUIRED = 2, MQTT_SSL_VERIFY_MODE_MAX }MQTT_SSL_Verify_Mode_t; MQTT_Connection_Status_t MQTT连接状态 typedef enum { /** Accepted */ MQTT_CONNECTION_ACCEPTED = 0, /** Refused protocol version */ MQTT_CONNECTION_REFUSED_PROTOCOL_VERSION = 1, /** Refused identifier */ MQTT_CONNECTION_REFUSED_IDENTIFIER = 2, /** Refused server */ MQTT_CONNECTION_REFUSED_SERVER = 3, /** Refused user credentials */ MQTT_CONNECTION_REFUSED_USERNAME_PASS = 4, /** Refused not authorized */ MQTT_CONNECTION_REFUSED_NOT_AUTHORIZED = 5, /** Disconnected */ MQTT_CONNECTION_DISCONNECTED = 256, /** Timeout */ MQTT_CONNECTION_TIMEOUT = 257, MQTT_CONNECTION_DNS_FAIL = 258, MQTT_CONNECTION_STATUS_MAX }MQTT_Connection_Status_t; MQTT_Flags_t MQTT标志位 typedef enum{ MQTT_FLAG_NONE = 0 , MQTT_FLAG_DATA_LAST = 1 , MQTT_FLAG_MAX }MQTT_Flags_t; 结构体类型 MQTT_Client_t MQTT对象 typedef struct{ void* mqttClient; }MQTT_Client_t; MQTT_Connect_Info_t MQTT连接配置信息 typedef struct{ /** Client identifier, must be set by caller */ const char *client_id; /** User name, set to NULL if not used */ const char* client_user; /** Password, set to NULL if not used */ const char* client_pass; /** keep alive time in seconds, 0 to disable keep alive functionality*/ uint16_t keep_alive; /** will topic, set to NULL if will is not to be used, will_msg, will_qos and will retain are then ignored */ const char* will_topic; /** will_msg, see will_topic */ const char* will_msg; /** will_qos, see will_topic */ uint8_t will_qos; /** will_retain, see will_topic */ uint8_t will_retain; uint8_t clean_session; /** SSL/TLS configuration for secure connections */ bool use_ssl; MQTT_SSL_Verify_Mode_t ssl_verify_mode; const char* ca_cert; const char* ca_crl; const char* client_cert; const char* client_key; const char* client_key_passwd; const char* broker_hostname; MQTT_SSL_Version_t ssl_min_version; MQTT_SSL_Version_t ssl_max_version; const char* entropy_custom; //自定义混淆字符 }MQTT_Connect_Info_t; 功能函数 MQTT_Connection_Callback_t typedef void (*MQTT_Connection_Callback_t)(MQTT_Client_t* client, void* arg, MQTT_Connection_Status_t status); 功能 连接回调函数 参数 client：MQTT客户端对象 arg：connect函数传的参数 status:MQTT连接状态 返回值 无 MQTT_Request_Callback_t typedef void (*MQTT_Request_Callback_t)(void* arg, MQTT_Error_t err); 功能 MQTT请求回调函数 参数 arg：发起请求时传的参数 err：错误信息 返回值 无 MQTT_InPub_Callback_t typedef void (*MQTT_InPub_Callback_t)(void* arg, const char* topic, uint32_t payloadLen); 功能 MQTT收到消息头回调函数，没有消息体，消息体在MQTT_InPub_Data_Callback_t中传入 参数 arg：设置回调函数时传的参数 topic：收到消息的主题 payloadLen：消息体长度 返回值 无 MQTT_InPub_Data_Callback_t typedef void (*MQTT_InPub_Data_Callback_t)(void* arg, const uint8_t* data, uint16_t len, MQTT_Flags_t flags); 功能 MQTT收到消息的消息体,MQTT_InPub_Callback_t后产生 参数 arg：设置回调函数时传入的参数 data：消息体数据 len：消息体数据长度 flags：标记，因为长数据可能被分段传输，MQTT_FLAG_DATA_LAST表示是消息的最后一段 返回值 无 MQTT_ClientNew MQTT_Client_t* MQTT_ClientNew(); 功能 创建MQTT客户端对象 参数 无 返回值 MQTT客户端对象 MQTT_Connect MQTT_Error_t MQTT_Connect(MQTT_Client_t* client, const char* domainOrIp,uint16_t port, MQTT_Connection_Callback_t callback, void* arg, const MQTT_Connect_Info_t* connectInfo); 功能 连接MQTT服务器(broker) 参数 client：MQTT客户端对象 domainOrIp：服务器地址 port：服务器端口 callback：连接成功回调函数 arg：需要传递给成功回调函数的参数 connectInfo:连接配置 返回值 MQTT连接错误信息 MQTT_Disconnect MQTT_Error_t MQTT_Disconnect(MQTT_Client_t* client); 功能 断开与MQTT服务器(broker)的连接 参数 client：MQTT客户端对象 返回值 MQTT连接错误信息 MQTT_SetInPubCallback void MQTT_SetInPubCallback(MQTT_Client_t* client, MQTT_InPub_Callback_t inpubCallback, MQTT_InPub_Data_Callback_t dataInpubCallback, void* arg); 功能 设置MQTT接收到订阅的消息时的回调函数 参数 client：MQTT客户端对象 inpubCallback：接收到订阅消息时的回调函数 dataInpubCallback：接收到订阅消息时的消息体回调函数 arg：需要传递给成功回调函数的参数 返回值 无 MQTT_Subscribe MQTT_Error_t MQTT_Subscribe(MQTT_Client_t* client, const char* topic, uint8_t qos, MQTT_Request_Callback_t callback, void* arg); 功能 向MQTT服务器(broker)发起订阅主题请求 参数 client：MQTT客户端对象 topic：主题 qos：服务质量 callback：订阅主题回调函数 arg：需要传递给回调函数的参数 返回值 MQTT连接错误信息 MQTT_Unsubscribe MQTT_Error_t MQTT_Unsubscribe(MQTT_Client_t* client, const char* topic, MQTT_Request_Callback_t callback, void* arg); 功能 从MQTT服务器(broker)取消订阅主题 参数 client：MQTT客户端对象 topic：主题 callback：订阅主题回调函数 arg：需要传递给回调函数的参数 返回值 MQTT连接错误信息 MQTT_Publish MQTT_Error_t MQTT_Publish(MQTT_Client_t* client, const char* topic, const void* payload, uint16_t payloadLen, uint8_t dup, uint8_t qos, uint8_t retain, MQTT_Request_Callback_t callback, void* arg); 功能 向MQTT服务器(broker)发布消息 参数 client：MQTT客户端对象 topic：主题 port：服务器端口 payload：消息体 payloadLen：消息体长度 dup：标示发送重复数 qos：服务质量 retain:需要服务器持久保存消息 callback：发布请求回调函数 arg：需要传递给回调函数的参数 返回值 MQTT连接错误信息 MQTT_IsConnected uint8_t MQTT_IsConnected(MQTT_Client_t* client); 功能 查询是否已经连接MQTT服务器(broker) 参数 client：MQTT客户端对象 返回值 如果已经连接，返回非0值，否则返回0 "},"c-sdk/gong-neng-ji-api/pmdian-yuan-guan-740629.html":{"url":"c-sdk/gong-neng-ji-api/pmdian-yuan-guan-740629.html","title":"PM(电源管理)","keywords":"","body":"Power Manager 电源管理 包含了一些基本的电源相关的操作，外设电源设置、关机、重启、低功耗等 电源按键按下释放会产生事件：API_EVENT_ID_KEY_DOWN，API_EVENT_ID_KEY_UP 例程：demo/pm 枚举类型 Power_Type_t 外设电源 typedef enum{ POWER_TYPE_VPAD = 0, // GPIO0 ~ GPIO7 and GPIO25 ~ GPIO36 2.8V //always on POWER_TYPE_MMC, // GPIO8 ~ GPIO13 1.9V POWER_TYPE_LCD, // GPIO14 ~ GPIO18 1.9V POWER_TYPE_CAM, // GPIO19 ~ GPIO24 1.9V POWER_TYPE_MAX }Power_Type_t; Power_On_Cause_t 开机原因 typedef enum{ POWER_ON_CAUSE_KEY = 0 , POWER_ON_CAUSE_CHARGE , POWER_ON_CAUSE_ALARM , POWER_ON_CAUSE_EXCEPTION, POWER_ON_CAUSE_RESET , POWER_ON_CAUSE_MAX }Power_On_Cause_t; 功能函数 PM_PowerEnable bool PM_PowerEnable(Power_Type_t powerType, bool isOn); 功能 使能外设电源，重要，在使用外设时一定要先打开电源，否则无法使用 参数 powerType：外设电源 isOn：开关 返回值 是否成功设置 PM_SleepMode void PM_SleepMode(bool isSleepMode); 功能 低功耗模式，低功耗模式会降低主频到32kHz，程序依然会运行，可以再调用这个函数恢复。 同时可以关闭外设及其电源来降低功耗 参数 isSleepMode：是否进入低功耗模式，true进入 返回值 无 PM_Voltage uint16_t PM_Voltage(uint8_t* percent); 功能 查看电池电压 参数 percent:电池电量百分比 返回值 电压值，单位：毫伏 PM_ShutDown void PM_ShutDown(); 功能 关机 参数 无 返回值 无 PM_Restart void PM_Restart(); 功能 系统重启 参数 无 返回值 无 "},"c-sdk/gong-neng-ji-api/dian-hua.html":{"url":"c-sdk/gong-neng-ji-api/dian-hua.html","title":"电话","keywords":"","body":"CALL 电话语音电话 电话语音支持语音通话即DTMF功能 例程：demo/call 枚举类型 CALL_DTMF_Gain_t DTMF 增益 typedef enum { CALL_DTMF_GAIN_0dB = 0, CALL_DTMF_GAIN_m3dB, CALL_DTMF_GAIN_m9dB, CALL_DTMF_GAIN_m15dB, CALL_DTMF_GAIN_MAX } CALL_DTMF_Gain_t; Power_On_Cause_t 错误信息 typedef enum{ CALL_ERROR_NONE = 0 , CALL_ERROR_NO_DIAL_TONE , //TERMINAL USER HAS POWERED OFF CALL_ERROR_BUSY , //TERMINAL USER RETURN UDUB CALL_ERROR_NO_ANSWER , //TERMINAL USER DOESN'T ANSWER THE CALL CALL_ERROR_NO_CARRIER , //remote hang up CALL_ERROR_NETWORK_TIME_OUT , CALL_ERROR_LINK_IS_BEINDG_BUILT , //link is being built, can not hang up CALL_ERROR_UNKOWN , CALL_ERROR_MAX }CALL_Error_t; 结构体 CALL_Status_t 电话状态信息 typedef struct { uint8_t index; uint8_t direction; uint8_t status; uint8_t mode; bool multiparty; char number[22]; uint8_t numberType; }CALL_Status_t; 功能函数 CALL_Dial bool CALL_Dial(const char* number); 功能 拨打电话 参数 number：号码 返回值 是否成功 CALL_HangUp bool CALL_HangUp(); 功能 挂电话 参数 无 返回值 是否成功挂断电话 CALL_Answer bool CALL_Answer(); 功能 接听电话 参数 无 返回值 是否成功接听电话 CALL_DTMF bool CALL_DTMF(char dtmf, CALL_DTMF_Gain_t attenuation, uint8_t duration, uint8_t speakerGain, bool send); 功能 拨DTMF，如果接收到对方哦DTMF，则会产生事件API_EVENT_ID_CALL_DTMF，param1是值，具体参考api_event.h 参数 dtmf:DTMF值，数值范围： '0'~'9', '#', '*', 'A'~'D' attenuation：衰减率 speakerGain：喇叭回响增益 send:是否发送出去，如果为false，只回响不实际发送出去 返回值 是否成功拨DTMF CALL_Status bool CALL_Status(CALL_Status_t** callStatus, uint8_t* count); 功能 查询电话状态信息，注意在调用后要调用OS_free对内存进行释放，比如： CALL_Status_t* callStatus = NULL; uint8_t count; bool ret = CALL_Status(&callStatus,count); uint8_t i; if(ret) { for(i=0;i 参数 callStatus: 指向存放状态信息数据块的指针 count: 电话状态信息个数 返回值 是否成功获取到电话状态信息，如果成功返回true，否则为false， "},"c-sdk/gong-neng-ji-api/smsduan-4fe129.html":{"url":"c-sdk/gong-neng-ji-api/smsduan-4fe129.html","title":"SMS(短信)","keywords":"","body":"SMS 短信功能 常用短信功能 例程：demo/sms 宏定义 SMS_PHONE_NUMBER_MAX_LEN 电话号码最长长度 #define SMS_PHONE_NUMBER_MAX_LEN 21 SMS_BODY_MAX_LEN 短信消息体最长长度（字节） #define SMS_BODY_MAX_LEN 176 枚举类型 SMS_Format_t 短信格式，目前仅支持文本格式 typedef enum{ // SMS_FORMAT_PDU = 0, // not support now SMS_FORMAT_TEXT = 1, // default SMS_FORMAT_MAX } SMS_Format_t; SMS_Error_t 错误信息 typedef enum{ SMS_ERROR_DECODE_ERROR = 0, SMS_ERROR_MAX } SMS_Error_t; SMS_Encode_Type_t 编码格式，包括ascii和unicode typedef enum{ SMS_ENCODE_TYPE_ASCII = 0, SMS_ENCODE_TYPE_UNICODE , SMS_ENCODE_TYPE_MAX } SMS_Encode_Type_t; SMS_Number_Type_t 号码地区类型 typedef enum{ SMS_NUMBER_TYPE_UNKNOWN = 129 , SMS_NUMBER_TYPE_INTERNATIONAL = 145 , SMS_NUMBER_TYPE_NATIONAL = 161 } SMS_Number_Type_t; //SMS_Server_Center_Addr_Type_t; SMS_Status_t 短信状态 typedef enum{ SMS_STATUS_UNREAD = 0x01 , SMS_STATUS_READ = 0x02 , SMS_STATUS_UNSENT = 0x04 , SMS_STATUS_SENT_NOT_SR_REQ = 0x08 , SMS_STATUS_SENT_SR_REQ_NOT_RECV = 0x10 , SMS_STATUS_SENT_SR_REQ_NOT_STORE = 0x20 , SMS_STATUS_SENT_SR_REQ_RECV_STORE = 0x40 , SMS_STATUS_ALL = 0x80 , SMS_STATUS_MAX } SMS_Status_t; SMS_Storage_t 短信储存位置 typedef enum{ SMS_STORAGE_FLASH = 1, SMS_STORAGE_SIM_CARD = 2, SMS_STORAGE_MAX } SMS_Storage_t; 结构体类型 SMS_Parameter_t 短信参数 typedef struct { uint8_t fo; // default: 17 uint8_t vp; // default: 167 uint8_t pid; // default: 0 uint8_t dcs; // default: 0:English 7bit, 4:English 8 bit, 8:Unicode 2 Bytes(UCS2) } SMS_Parameter_t; SMS_Server_Center_Info_t 短信中心信息 typedef struct{ char* addr; SMS_Number_Type_t addrType; } SMS_Server_Center_Info_t; SMS_Message_Info_t 短消息 typedef struct{ //header uint8_t index; SMS_Status_t status; SMS_Number_Type_t phoneNumberType; char phoneNumber[SMS_PHONE_NUMBER_MAX_LEN]; RTC_Time_t time; //body uint16_t dataLen; uint8_t* data; } SMS_Message_Info_t; SMS_Storage_Info_t 短消息储存信息 typedef struct{ uint16_t used; uint16_t total; uint16_t unReadRecords; uint16_t readRecords; uint16_t sentRecords; uint16_t unsentRecords; uint16_t unknownRecords; uint16_t storageId; } SMS_Storage_Info_t; 功能函数 SMS_SetFormat bool SMS_SetFormat(SMS_Format_t format, SIM_ID_t simID); 功能 设置短信格式 参数 format:格式，目前仅支持字符格式 simID：卡ID，仅支持SIM0 返回值 是否成功 SMS_SetParameter bool SMS_SetParameter(SMS_Parameter_t* smsParameter,SIM_ID_t simID); 功能 设置短信参数 参数 smsParameter:短信参数 simID:卡ID，仅支持SIM0 返回值 是否成功 SMS_SendMessage bool SMS_SendMessage(const char* phoneNumber, const uint8_t* message, uint8_t length, SIM_ID_t simID); 功能 发送短信 参数 phoneNumber：电话号码 message：短信内容，注意必须是unicode编码，可以用SMS_LocalLanguage2Unicode转换 length：短信长度（字节） simID:固定为SIM0 返回值 是否成功发送 SMS_SetServerCenterInfo bool SMS_SetServerCenterInfo(SMS_Server_Center_Info_t* serverCenterInfo); 功能 设置短信中心信息 参数 serverCenterInfo：短信中心信息 返回值 是否成功设置短信中心信息 SMS_GetServerCenterInfo bool SMS_GetServerCenterInfo(SMS_Server_Center_Info_t* serverCenterInfo); 功能 获取短信中心信息 参数 serverCenterInfo：短信中心信息 返回值 是否成功获取短信中心信息 SMS_ListMessageRequst bool SMS_ListMessageRequst(SMS_Status_t smsStatus,SMS_Storage_t storage); 功能 请求列出保存的短信，短信信息会以事件的方式产生API_EVENT_ID_SMS_LIST_MESSAGE，具体参数看api_event.h 参数 smsStatus：选择列出哪些类型的短信，比如只列出未读消息SMS_STATUS_UNREAD 返回值 是否成功请求读取短信 SMS_DeleteMessage bool SMS_DeleteMessage(uint8_t index,SMS_Status_t status,SMS_Storage_t storage); 功能 删除保存的短信 参数 index：保存的短信的下标 storage：选择储存位置，flash还是SIM卡 返回值 是否成功删除短信 SMS_GetStorageInfo bool SMS_GetStorageInfo(SMS_Storage_Info_t* storageInfo, SMS_Storage_t storage); 功能 获取短信储存信息 参数 storageInfo：储存信息 storage：选择要查询的储存位置 返回值 是否成功查询 SMS_SetNewMessageStorage bool SMS_SetNewMessageStorage(SMS_Storage_t storage); 功能 选择新收到的消息储存的位置 参数 storage：新消息储存的位置 返回值 是否成功设置新消息储存位置 SMS_GetCharset const char* SMS_GetCharset(Charset_t charset); 功能 获取特定字符集的ascii名称 参数 charset：字符集 返回值 对应字符集的ascii名称 SMS_Unicode2LocalLanguage bool SMS_Unicode2LocalLanguage(uint8_t* unicodeIn, uint16_t unicodeLenIn, Charset_t localLanguage, uint8_t** localOut, uint32_t* localLenOut); 功能 unicode转本地语言 参数 unicodeIn：unicode编码的消息 unicodeLenIn：unicode编码的消息长度 localLanguage：要转换成的本地语言 localOut:转换好的本地语言 localLenOut：转换好的本地语言长度 返回值 是否成功转换 SMS_LocalLanguage2Unicode bool SMS_LocalLanguage2Unicode(uint8_t* localIn, uint16_t localLenIn, Charset_t localLanguage, uint8_t** unicodeOut, uint32_t* unicodeLenOut); 功能 本地语言转unicode编码 参数 localIn：本地语言消息体 localLenIn：本地语言消息体长度 localLanguage：本地编码格式 unicodeOut：转换好的unicode编码消息体 unicodeLenOut：转换好的unicode编码消息体长度 返回值 是否成功转换 "},"c-sdk/gong-neng-ji-api/fota.html":{"url":"c-sdk/gong-neng-ji-api/fota.html","title":"FOTA(远程固件升级)","keywords":"","body":"FOTA 参考例程 demo/fota 升级流程简介 考虑到流量使用以及flash空间占用，升级使用了查分升级的方式，类似Android中的App增量更新，每次升级必须在上一次的基础上进行升级，因此每次生成固件后需要保留旧固件方便以后升级使用 每次的升级包最大64kB， 如果使用到了FOTA功能，堆需要预留最大64kB的空间，以及文件系统也需要预留64kB 应用程序通过串口或者网络获取升级包并保存到flash中的文件系统中 获取升级包完毕后会自动重启进入升级序列 这时会通过HST口打印事件，事件的数值及其含义如下： #define FOTA_EVENT_START_CHECK 0xf07a0000 #define FOTA_EVENT_VERSION_ERROR 0xf07a0001 #define FOTA_EVENT_STATUS_EMPTY 0xf07a0002 #define FOTA_EVENT_STATUS_DOWNLOADING 0xf07a0003 #define FOTA_EVENT_STATUS_DOWNLOADED 0xf07a0004 #define FOTA_EVENT_STATUS_UPGRADING 0xf07a0005 #define FOTA_EVENT_STATUS_UPGRADED 0xf07a0006 #define FOTA_EVENT_AREA_INVALID 0xf07a0007 #define FOTA_EVENT_UPGRADE_START 0xf07a0008 #define FOTA_EVENT_UPGRADE_PROGRESS 0xf07a0009 #define FOTA_EVENT_UPGRADE_FAILED 0xf07a000a #define FOTA_EVENT_UPGRADE_DONE 0xf07a000b 升级过程也会汇报进度，事件共4个字节，前两个是总进度，后两个字节则是当前进度即值为(total 如果在升级过程中出现了错误，比如断电，下次上电会继续升级过程直到升级完成,因此断电不会造成固件损坏 例程使用 例程做的事情就是开机后从服务器获得升级包进行固件升级或者接收来自串口的升级包进行固件升级， 需要注意的是升级使用的是差分升级，每一次升级必须要在上一次的固件基础上进行升级 进入工程主目录，./build.bat clean清理工程 修改例程代码： 使用串口升级或者通过http服务器升级，通过注释代码选择 // FOTA_UartTest(); FOTASERVER_Test(); 如果是服务器升级，需要修改服务器固件地址，即升级包的地址， 比如： #define SOFT_VERSION \"V3.0\" #define FOTA_HTTP_SERVER \"http://test.ai-thinker.com/csdk/fota/%stonew.pack\" 后面我们生成的升级包就需要将名字改成V3.0tonew.pack ./build.bat demo fota 编译生成老版本固件，在hex/fota文件夹下可以看到fota_*_debug.lod和fota_*_debug_ota.lod,备份hex/fota/fota_*_debug_ota.lod为hex/fota/old.lod,同时备份好旧固件或者直接备份hex/fota文件夹 新版不再生成*_ota.lod这个文件，使用完整的lod文件即可 修改代码，及新的代码比如这里修改 #define SOFT_VERSION \"V3.0\" 为 #define SOFT_VERSION \"V3.1\" 编译新版本固件,./build.bat demo fota,同理得到hex/fota/new.lod 生成升级包, ./build.bat fota hex/fota/old.lod hex/fota/new.lod V3.0tonew.pack，这里第四个参数就是之前链接里的名字，如果串口升级名字无所谓。并将这个升级包拷贝到http服务器代码中对应的升级地址。 注意这里各个固件的路径 下载老版本固件(fota_*_debug.lod)到硬件运行，如果是串口升级则用串口发送升级文件*.pack，等待升级完毕后重启；如果是http服务器升级，例程上电后会自动联网获取升级包进行升级，升级完毕后自动重启。 升级完成后可以看到打印的消息中，版本从3.0升级到了3.1 "},"c-sdk/gong-neng-ji-api/lbs.html":{"url":"c-sdk/gong-neng-ji-api/lbs.html","title":"LBS","keywords":"","body":"LBS 基站定位获取经纬度 在某些场景中，需要使用到经纬度来判断模块所在的位置，但是又不需要十分精确的位置，这个时候可以不使用GPS，使用基站定位即可实现这个功能 基站定位的原理主要是通过GSM模块获取到周围的基站信息，然后将这些基站信息通过GPRS发送到位置服务器，服务器可以根据基站信息计算出大致的经纬度后返回给模块 所以如果需要使用LBS，可以自己搭建服务器（推荐），GPRS模块通过长传基站信息来获得经纬度信息； 也可以使用SDK中的api，暂时只支持国内位置查询 demo/lbs 功能函数 LBS_GetLocation bool LBS_GetLocation(Network_Location_t* bsInfo, uint8_t bsNumber,int timeoutS, float* longitude, float* latitude); 功能 通过基站信息获得经纬度，使用前保证网络已经激活可用 参数 bsInfo: 基站信息，通过Network_GetCellInfoRequst获得 bsNumber: 基站数量 timeoutS: 网络超时时间 longitude: 纬度返回值 latitude: 经度返回值 返回值 是否成功获取到经纬度 "},"c-sdk/gong-neng-ji-api/gizwits.html":{"url":"c-sdk/gong-neng-ji-api/gizwits.html","title":"Gizwits(机智云)","keywords":"","body":"Gizwits 机智云 机智云使用简单，很适合快速搭建应用，SDK中集成了机智云协议，使用几个简单的API即可快速接入 更多详细介绍可以前往机智云官网 例程：demo/gizwits 枚举类型 Gizwits_Action_t action 编号 typedef enum{ GIZWITS_FIXED_LENGTH_ACTION_CONTROL = 0x01 , GIZWITS_FIXED_LENGTH_ACTION_READ_STATUS = 0x02 , GIZWITS_FIXED_LENGTH_ACTION_READ_STATUS_ACK = 0x03 , GIZWITS_FIXED_LENGTH_ACTION_REPORT_STATUS = 0x04 , GIZWITS_FIXED_LENGTH_ACTION_TRANS_RECV = 0x05 , GIZWITS_FIXED_LENGTH_ACTION_TRANS_SEND = 0x06 , GIZWITS_FIXED_LENGTH_ACTION_PUSH_OTA = 0xfe , GIZWITS_VARIABLE_LENGTH_ACTION_CONTROL = 0x11 , GIZWITS_VARIABLE_LENGTH_ACTION_READ_STATUS = 0x12 , GIZWITS_VARIABLE_LENGTH_ACTION_READ_STATUS_ACK = 0x13 , GIZWITS_VARIABLE_LENGTH_ACTION_REPORT_STATUS = 0x14 , GIZWITS_VARIABLE_LENGTH_ACTION_TRANS_RECV = 0x15 , GIZWITS_VARIABLE_LENGTH_ACTION_TRANS_SEND = 0x16 , GIZWITS_VARIABLE_LENGTH_ACTION_PUSH_OTA = 0xfe , GIZWITS_ACTION_MAX }Gizwits_Action_t; 结构体类型 Gizwits_Config_t Gizwits配置,必须配置IMEI、pk、pk_secret、alive，pk和pk secret可以在机智云控制面板中创建的应用中找到 typedef struct { char imei[32]; char did[32]; char passcode[16]; char pk[48]; char pk_secret[48]; char hard_version[16]; char soft_version[16]; uint16_t alive; }Gizwits_Config_t; Gizwits_t 机智云对象 typedef struct{ Gizwits_Config_t* config; void* cloud; char* otaUrl; }Gizwits_t; 功能函数 OnReceivedOnePacket_Callback_t typedef void (*OnReceivedOnePacket_Callback_t)(Gizwits_t* gizwits, Gizwits_Action_t action,uint8_t* data, int len); 功能 数据接收回调函数 参数 gizwits: 机智云对象 action: 动作 data: 数据 len: 数据长度 返回值 无 GIZWITS_GetConfig bool GIZWITS_GetConfig(Gizwits_Config_t* config, const char* path); 功能 获取机智云配置 参数 config: 机智云配置 path: 配置文件存放路径，比如\"/gizwits_config.conf\" 返回值 是否成功地从文件读取到配置 GIZWITS_Connect int GIZWITS_Connect(Gizwits_t* gizwits, Gizwits_Config_t* config, const char* configPath); 功能 连接机智云，如果配置对象中的did值为空，则会先注册机智云再登录，需要注意的是，每次重新注册，用户绑定的设备将会自动解绑，即如果设备重新注册，就算之前已经绑定了这个设备的用户也需要重新扫码绑定 参数 gizwits: 机智云对象 config: 机智云配置 configPath: 机智云配置文件路径，用于注册成功后保存did等信息 返回值 是否成功连接到机智云，成功则返回0，否则返回错误代码 GIZWITS_Send int GIZWITS_Send(Gizwits_t* gizwits, Gizwits_Action_t action, uint8_t* data, int len); 功能 推送数据到机智云 参数 gizwits: 机智云对象 action: 动作 data: 需要发送的数据 len: 需要发送的数据的长度 返回值 是否成功发送数据到机智云，成功则返回0，否则返回错误代码 GIZWITS_DoReceive int GIZWITS_DoReceive(Gizwits_t* gizwits, OnReceivedOnePacket_Callback_t onOnePacket); 功能 处理来自机智云的消息，在socket接收到数据时调用 参数 gizwits: 机智云对象 onOnePacket: 数据回调函数 返回值 返回接收到的原始数据的长度，否则返回错误代码 GIZWITS_Ping bool GIZWITS_Ping(Gizwits_t* gizwits); 功能 发送心跳包到机智云，在连接到机智云的配置信息中配置了alive时长，在这段时间内必须调用这个函数给机智云发送心跳包，否则会被服务器判定为已经掉线并强制断开连接 参数 gizwits: 机智云对象 返回值 发送心跳包是否成功 GIZWITS_GetSocket int GIZWITS_GetSocket(Gizwits_t* gizwits); 功能 获取连接到机智云的socket描述符 参数 gizwits: 机智云对象 返回值 socket描述符，大于零 GIZWITS_Close bool GIZWITS_Close(Gizwits_t* gizwits); 功能 关闭连接 参数 gizwits: 机智云对象 返回值 关闭机智云连接是否正常 "},"Q_A/q_a.html":{"url":"Q_A/q_a.html","title":"常见问题","keywords":"","body":"常见问题 Q&A 什么是git,什么是github,有什么区别 在文档中可能会出现git等关键词,git是一个代码托管工具, 代码托管即可简单理解为记录我们的代码修改记录,当我们需要的时候可以随时回到过去的版本, 以及查看在什么时候修改了哪一行代码(没错精确到行). github则是基于git版本管理工具的一个网站,我们可以把代码放到这个网站,其他人就可以查看并且一起协同修改了. 为什么git clone到本地后编译无法通过 工程使用git进行版本管理,为了让工程的体积不会随着更新疯狂增加,所以使用了子模块,关于子模块的内容可以自行搜索. 因此,执行clone命令后,需要执行git submodule update --init命令对子模块进行初始化和更新,否则SDK文件不全. 或者clone时使用--recursive参数,如果这种方式无法克隆,则使用上面先克隆再更新子模块的方式可以解决 为什么Windows下面和linux下面生成的lod文件大小不一样? 本工程生成的lod文件是字符文件,不是二进制文件,所以会比较大, 总所周知,字符文件在windows和linux下默认的换行符是不同的, linux下使用的换行符是LF(\\n),windows下使用CRLF(\\r\\n), 所以每多一个换行符,windows生成的lod文件就会比linux生成的会多一个字节, 因此,windows上生成的lod文件会比linux上的lod文件大一点,但是不会对程序有任何影响 为什么没有IDE,没有像keil一样的IDE么? 没有提供IDE,提供单独的工具链(编译链接工具)和下载软件, 编写软件可以自由选择编辑器, 比如使用VS Code,支持跳转,对于没法跳转的可以使用全局搜索,速度很快很方便 也可以用eclipse开发 为什么有时会无法下载程序到模块? 程序不要进入休眠模式,不要使用while(1){};代码, 以及串口的问题, 可以尝试:按复位键,模块启动后(下载串口的数据通信指示灯开始闪烁)立马点击下载按钮 不用TF卡,可以把数据存到内部flash中么? SDK集成了文件系统,文件系统就是flash上的,所以对文件系统的操作就可以看成是对flash的操作,可以把配置文件存到文件系统中. 所以,不用TF卡也可以通过文件系统的API将数据存到flash文件系统中 TF卡最大支持多大？ 16G fat32 支持那些网络? 2G基站关闭了怎么办? 模块使用RDA8955这款芯片,支持4频段:800/900/1800/1900MHz, 在国内建议使用移动卡,移动未宣布关闭2G基站,联通已经决定关闭2G基站 其它地区建议先进行测试 为什么有时候会重启? 重启一般是因为两个原因造成的 电源供电不足,导致断电重启 系统程序bug 很多情况下都是因为电源问题造成的, 蜂窝网要求电源设计为2A,如果达不到就可能会出现联网通信或打电话或者信号差的时候就会重启 如果使用C SDK编译debug版本的固件,死机后不会重启,会阻塞(除了手动设置了看门狗),如果是debug版本也重启了并且没有自己使用过看门狗功能,那一定是电源的问题 如果使用release版本或者添加了看门狗功能,有可能是程序出现了问题,一般是指针越界操作导致的 编译函数重定义错误 multiple definition of `****' 如果报的错误是函数重定义并且后面跟着一大段文字如下: multiple definition of `****' mips-elf-ld: Dwarf Error: Can't find .debug_ranges section. mips-elf-ld: Dwarf Error: Can't find .debug_ranges section. mips-elf-ld: Dwarf Error: Can't find .debug_ranges section. mips-elf-ld: Dwarf Error: Can't find .debug_ranges section. 则是因为函数名与已有的库中的函数名重复. 解决办法: 方法一: 修改函数名 方法二: 将重定义的函数名添加到platform/compilation/platform_symbols_to_strip文件中即可编译通过(可以简单地理解成屏蔽了库中的函数) 这里这个文件是将库elf文件中的函数的标志去掉,这样链接时就不会报错了，但是这样有可能会导致debug时找不到函数名 另外一个原因可能是代码中确实有重定义即多个函数名相同的函数 阿里云在windows编译报错 比如阿里云在windows上编译报错,是因为阿里云官方的makefile语法不适配cygwin导致的, 阿里云的代码目前只能在linux编译,也许后面会解决 文档和代码不一致或者文档没有说明怎么办? 在开发中的代码可能文档更新不及时,尽量先看已有的文档,在api每个文档的开头都会有重要提示,如果不看可能会遇到坑, 工程的代码也尽量写得比较简单易懂,可以多看看demo下的例程和.h文件, 再不懂则可以提交issue或者论坛发问或者发邮件询问 如何获取IMEI? 可以使用SDK中的API获取,或者用手机扫描模块屏蔽壳的二维码即可得到 为什么总是提示SIM无法识别或者掉卡? 检查是否有SIM卡 检查SIM接触是否正常,触电不能有胶覆盖(比如有涂三防漆涂到了触电的例子) 检查SIM卡线路走线是否正规,尽量离模块近一点,周围不要有干扰,模块的天线引脚和SIM卡引脚相隔比较近,注意走线使其不相互影响 为什么低功耗时达不到说的2mA? 模块低功耗可以达到2mA的电流是没错的,8955通过降低主频以及关闭外设来降低功耗, 如果还有部分外设处在使用中的情况,电流可能不会降下来,以及在信号弱的地方为了保持网络连接,可能会有电流上升的情况 如果进入飞行模式,则GSM/GPRS协议栈关闭,也会大大降低电流,但是无法打电话发短信上网,其它功能正常使用 所以,要使用低功耗尽量关闭外设,保持信号良好 为什么GPS会漂,不是说好的定位精度5米么? GPS在空旷的环境中可以有比较理想的效果,在有遮蔽的地方会对定位精度有影响 可以使用arduino开发么? 目前不可以,没有移植arduino库,有兴趣学习的可以自己尝试移植试试 为什么定时器的时间不是十分准确? 定时器是软件定时器,不是硬件定时器,不适用在高精度的定时任务上。 由于是软件定时器，时间到了会产生事件，这个事件会在OS_WaitEvent进行处理， 并且开启定时器时设置的回调函数也是在这个函数里面进行调用。 综上所述， 在使用定时器时有些地方需要注意，因为是软件定时器并且有事件调度，所以必须有地方用OS_WaitEvent及时接收、处理来自定时器的事件， 尽量不要在回调函数里面处理太长事件，以免影响一下个定时器的事件及时接收处理； 建议使用一个单独的优先级最高的任务来专门处理定时器事件，具体可以参考demo/timer_soft 使用OS_Malloc后，为何调用OS_GetHeapUsageStatus查询剩余堆空间值一直不变 原因请查看文档中os部分的OS_GetHeapUsageStatus函数说明，分配小空间后调用这个函数的返回值可能不会有变化 死机： 在SXR 01调试等级有打印出 No more envelope 原因是使用了OS_SendEvent函数来发送事件，但是没有及时处理事件导致满队。 需要使用OS_WaitEvent来等待事件并处理，比如所有例程中都以一个主任务用来处理底层发来事件， 同理，如果不去接收处理来自底层的事件，经过很长时间队列满后也会溢出出现死机 解决方法：检查哪些地方调用了这个函数，并且检查哪里有没有及时处理这些发送的事件，保证事件在队列满之前及时处理掉就可以了 "},"more/flash_map.html":{"url":"more/flash_map.html","title":"进阶","keywords":"","body":"Flash 分区布局 内置了4M Flash，其中留给用户程序的空间位1M，详情如下表： 地址 空间大小 功能 0x000000~0x099999 64 (kB) Bootloader 0x100000~0x239999 1.25 (MB) platform 0x240000~0x339999 1M (MB) APP 0x340000~0x379999 256 (kB) reserved 0x380000~0x389999 64 (kB) FOTA backup 0x390000~0x3F5999 408 (kB) SPIFFS 0x3F6000~0x3F9999 16 (kB) FatFS(deprecated) 0x3FA000~0x3FB999 8 (kB) Calib1 0x3FC000~0x3FD999 8 (kB) Calib2 0x3FE000~0x3FE9999 8 (kB) Factory CFG 用户程序在APP分区中 文件系统在SPIFFS分区中 旧的FatFS因为读写均衡原因弃用了，但是考虑到历史原因，该分区仍保存，尽量不要再使用这个文件系统 系统配置分区以及校准分区为出厂时写入，请不要随意修改和擦除 FOTA backup 分区是用来在FOTA升级时保证升级正常进行的备份分区，请勿另作他用 reserved分区目前没有使用，在APP分区使用完之前不建议使用这个分区，可能在将来会使用 platform是系统底层代码存放区域，请勿修改 bootloader为启动引导分区，请勿修改 "},"more/gen_lib.html":{"url":"more/gen_lib.html","title":"如果将SDK生成一个lib库文件","keywords":"","body":"将SDK生成为一个库(lib文件) 使用 platform/tools/genlib/genlib.sh脚本 cd platform/tools/genlib chmod +x genlib.sh #./genlib.sh clean ./genlib.sh debug # ./genlib.sh release 生成成功后在build/csdk/lib/目录下会有lib*.a "},"more/mpy.html":{"url":"more/mpy.html","title":"移植脚本语言MicroPython","keywords":"","body":"移植micropython micropython是一个适用在嵌入式设备上的裁剪版python,使用它可以更方便简单地开发程序,A9/A9G的性能完全可以胜任micropython的要求 已经尝试进行移植,确认可行,如果有兴趣可以研究, 参考这里:GPRS_A9 MicroPython code "}}